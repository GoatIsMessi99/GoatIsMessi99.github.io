<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 嘉禾望岗</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="嘉禾望岗" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/main.png" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">嘉禾望岗</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['锄禾日当午，不知编程苦', '改了一下午，bug缝又补', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-进程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/29/%E8%BF%9B%E7%A8%8B/"
    >Linux进程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/29/%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time datetime="2023-04-28T16:00:00.000Z" itemprop="datePublished">2023-04-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-进程的概念"><a href="#1-进程的概念" class="headerlink" title="1. 进程的概念"></a>1. 进程的概念</h2><ul>
<li>进程是操作系统对正在运行的程序实例的一种抽象</li>
<li>进程是操作系统分配系统资源的基本单位</li>
<li>每个进程之间是相对独立的</li>
</ul>
<p>计算机上运行着各种各样的程序，操作系统系统为了方便管理这些程序，将它们统一抽象成进程，这样就可以以统一的视角去管理这些程序，从而提高对系统资源的管理能力和利用率。</p>
<p>当我们运行一个可执行程序时，操作系统会创建并初始化<strong>进程控制块 PCB（Process Control Block）</strong>，PCB里面就记录了可执行程序的各种属性：状态、标识符、优先级等等，通过这种方式，操作系统就将对可执行程序的管理转化成了对进程控制块的管理，如果使用各种数据结构将所有进程控制块管理起来，操作系统就完成了对计算机上所有可执行程序的管理。</p>
<p>Linux下的进程控制块就是task_struct结构体，以下是一个简化版的task_struct:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;                  <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">thread_info</span>;</span> <span class="comment">// 线程信息</span></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">stack</span>;  <span class="comment">// 进程内核栈</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> <span class="comment">// 父进程指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>  <span class="comment">// 子进程列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">siblings</span>;</span>  <span class="comment">// 兄弟进程列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>       <span class="comment">// 进程地址空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">cwd</span>;</span>           <span class="comment">// 当前工作目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span> <span class="comment">// 信号信息</span></span><br><span class="line">    <span class="type">int</span> exit_code;              <span class="comment">// 退出状态码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在创建进程控制块时，操作系统做了以下几个主要工作：</p>
<ol>
<li>初始化进程控制块task_struct：它记录了进程的状态、进程标识符、进程优先级等信息。</li>
<li>分配进程地址空间：每个进程都有自己的虚拟地址空间，用于存放代码、数据和堆栈等信息。在创建进程时，内核会为该进程分配一个独立的虚拟地址空间，并将程序、数据和库文件等载入其中。</li>
<li>复制父进程的内存空间：由于 Linux 使用了写时拷贝（Copy-on-Write，COW）技术，因此在创建进程时，内核会将父进程的内存空间复制一份，但是这些内存页并没有被实际复制，而是被标记为只读，当子进程需要修改其中的某个内存页时，内核会为其分配一个新的内存页，并将修改后的数据写入其中。</li>
<li>复制父进程的文件描述符表：文件描述符表是进程用于管理文件和网络连接等资源的数据结构，在创建进程时，内核会将父进程的文件描述符表复制一份，并将其与子进程关联起来。</li>
<li>设置进程的环境变量和命令行参数：每个进程都有自己的环境变量和命令行参数，这些信息用于指定进程的运行环境和参数。在创建进程时，内核会将父进程的环境变量和命令行参数复制一份，并将其与子进程关联起来。</li>
<li>设置进程的信号处理器：信号是进程间通信的一种方式，在 Linux 中，每个进程都可以设置自己的信号处理器。在创建进程时，内核会将父进程的信号处理器复制一份，并将其与子进程关联起来。</li>
</ol>
<h2 id="2-进程控制"><a href="#2-进程控制" class="headerlink" title="2. 进程控制"></a>2. 进程控制</h2><p>在shell命令行中使用ps命令查看系统当前运行的进程：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/2.1.png"></p>
<ul>
<li>PPID是父进程的进程ID</li>
<li>PID是该进程的进程ID</li>
<li>PGID是进程组的ID</li>
<li>SID是当前会话的ID</li>
<li>STAT是当前进程的状态</li>
</ul>
<p>其中，Linux下进程状态有以下几种：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/2.2.png"></p>
<p>其他状态字符：</p>
<ul>
<li>+   &#x2F;&#x2F;位于后台的进程组；</li>
<li>s   &#x2F;&#x2F;进程组组长</li>
<li>&lt;   &#x2F;&#x2F;优先级高的进程 </li>
<li>N   &#x2F;&#x2F;优先级较低的进程 </li>
<li>L   &#x2F;&#x2F;有些页被锁进内存； </li>
<li>l   &#x2F;&#x2F;多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）</li>
</ul>
<h4 id="2-1-fork"><a href="#2-1-fork" class="headerlink" title="2.1 fork"></a>2.1 fork</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       fork()  creates a new process by duplicating the calling process. The new process, referred to as the child, is an exact duplicate of the calling process, referred to as the parent, except for the following points:</p>
</blockquote>
<p>调用fork会在当前进程中创建出新进程（称为子进程），继承父进程下列资源：</p>
<ul>
<li>父进程的代码段、数据段、堆栈段等代码和状态信息</li>
<li>父进程打开的文件描述符</li>
<li>父进程的环境变量、工作目录、umask</li>
<li>父进程的信号处理方式</li>
<li>将父进程的pid设为自己的ppid</li>
</ul>
<p>有以下区别：</p>
<ul>
<li>子进程拥有自己的进程pid、地址空间</li>
<li>子进程的信号量、内存锁、资源利用率、CPU时间计数器全部重置</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>       On  success,  the  PID  of the child process is returned in the parent, and 0 is returned in the<br>       child.  On failure, -1 is returned in the parent, no child process is created, and errno is  set<br>       appropriately.</p>
</blockquote>
<p>如果fork创建成功，fork会在父进程中返回子进程的pid，在子进程中返回0，否则在父进程中返回-1。</p>
<p>以下是一个简单的fork示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;executed\n&quot;</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;fork err\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;pid: &quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot; parent\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ppid: &quot;</span>&lt;&lt;getppid()&lt;&lt;<span class="string">&quot; pid: &quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot; child\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Not executed\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos test]$ ./test</span><br><span class="line">executed</span><br><span class="line">pid: <span class="number">8051</span> parent</span><br><span class="line">Not executed</span><br><span class="line">ppid: <span class="number">8051</span> pid: <span class="number">8052</span> child</span><br><span class="line">Not executed</span><br></pre></td></tr></table></figure>

<p>上述代码中，getpid()可以获取进程pid，getppid（）可以获取父进程pid.</p>
<p>由结果可知，子进程继承了父进程代码段，子进程执行和父进程相同的代码段。</p>
<p><strong>Question:子进程执行和父进程相同的代码段，为什么没有执行std::cout&lt;&lt;”executed\n” ?</strong></p>
<p>原因：子进程继承了父进程的状态信息，其中就包括父进程PC指针寄存器的值，父进程fork时，PC指针指向pid_t pid &#x3D; fork()。因此子进程开始执行代码时，PC指针已经指向了pid_t pid &#x3D; fork() ，并从下一行代码开始执行，所以不会执行std::cout&lt;&lt;”executed\n”。</p>
<h4 id="2-2-写时拷贝（Copy-on-Write，COW）"><a href="#2-2-写时拷贝（Copy-on-Write，COW）" class="headerlink" title="2.2  写时拷贝（Copy-on-Write，COW）"></a>2.2  写时拷贝（Copy-on-Write，COW）</h4><blockquote>
<p>In Linux, when a process creates a new process (child process) through the fork() system call, the new process initially shares the same memory as the parent process. With COW, the operating system only creates a copy of the parent process’s memory pages when the child process modifies them.</p>
</blockquote>
<p>COW技术指fork子进程时，Linux系统内核会为子进程创建独立的地址空间，子进程的页表是父进程页表的一份拷贝，同时设置子进程页表中的写保护标志，此时子进程和父进程共享相同的物理内存。只有当子进程或者父进程需要修改这块共享物理内存上的值时，操作系统会捕获到写保护异常，此时才会开辟新的物理内存空间，填入修改后的值，并将子进程页表中对应的虚拟地址映射到新的物理内存空间上。</p>
<p>这种设计可以避免不必要的物理内存空间拷贝，只有在实际需要修改物理内存时，才会发生数据的复制，从而节省了内存和时间。</p>
<p>以下是一段父进程修改共享物理内存值时，发生写时拷贝的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x =<span class="number">0</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;x&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos test]$ g++ test.cc -o test -<span class="built_in">std</span>=c++<span class="number">11</span></span><br><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos test]$ ./test</span><br><span class="line"><span class="number">0x7ffdbb1f8618</span>:<span class="number">10</span></span><br><span class="line"><span class="number">0x7ffdbb1f8618</span>:<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>由于子进程拷贝父进程的代码段、数据段、堆栈空间，所以X的虚拟地址相同，当父进程修改x变量的值时，发生了写时拷贝，在物理内存上开辟了新的空间存放子进程x变量的值，并将子进程页表中X的虚拟地址映射到新的物理内存中。而用户只能看到进程空间中的虚拟地址，看不到实际的物理内存地址，这也导致了我们看到了“相同的地址”，存放的值却不同的现象。</p>
<p>刚创建子进程时，父子进程共享同一块物理内存：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.1.png"></p>
<p>父进程修改共享物理内存时：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.2.png"></p>
<h4 id="2-3-exit-x2F-exit"><a href="#2-3-exit-x2F-exit" class="headerlink" title="2.3 exit&#x2F;_exit"></a>2.3 exit&#x2F;_exit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       The  function  _exit()  terminates  the  calling  process “immediately”.  Any open file descriptors belonging to the process are closed; any children of the process are inherited by process 1, init, and the process’s parent is sent a SIGCHLD signal.</p>
<p>​	  The value status is returned to the parent process as the process’s exit status, and can be collected using one of  the  wait<br>family of calls.</p>
</blockquote>
<p>调用_exit会终止当前进程，关闭当前进程打开的所有文件描述符，<strong>该进程的所有的子进程都会被进程标识符为1的进程继承（就是操作系统）</strong>，同时向该进程的父进程发送SIGCHLD信号，父进程可以通过wait接口获得子进程状态码status。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>

<p>exit与_exit都可以用来终止进程，但有以下区别：</p>
<ul>
<li>_exit立刻终止进程，exit还会执行清理函数</li>
<li>_exit不会刷新缓冲区，exit会刷新缓冲区</li>
</ul>
<p><strong>为了提高系统资源的利用效率，进程终止时，操作系统不会立即释放task_struct，会将它放入到数据结构缓冲池（slab分发器）中，留给下一个进程使用，从而避免频繁的创建task_strcut,增加系统的开销。</strong></p>
<h4 id="2-4-wait"><a href="#2-4-wait" class="headerlink" title="2.4 wait"></a>2.4 wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       All of these system calls are used to wait for state changes in a child of the calling process, and obtain information about the<br>       child whose state has changed.  A state change is considered to be: the child terminated; the child was stopped by a signal;  or<br>       the  child  was  resumed  by  a  signal.   In the case of a terminated child, performing a wait allows the system to release the<br>       resources associated with the child; if a wait is not performed, then the terminated child remains  in  a  “zombie”  state  </p>
</blockquote>
<p>wiat接口会阻塞等待某个子进程的状态改变。当子进程状态改变时，wait会获得子进程的状态，释放子进程的资源。如果没有调用wait，子进程将会保持“zombie”状态，成为僵尸进程。</p>
<p>子进程状态改变意味着发生以下情况：</p>
<ul>
<li>子进程被终止</li>
<li>子进程被信号暂停或重启</li>
</ul>
<p>参数的设置：</p>
<ul>
<li>status是输出型参数，有效位为16位，高8位是status，低8位分别是1位core dump标志和7位终止信号</li>
</ul>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.3.png"></p>
<p>我们可以右移8位获得status，按位与获得终止信号，也可以使用内核提供的宏来获得值</p>
<ul>
<li>WEXITSTATUS(status) 提取子进程退出码</li>
<li>WTERMSIG(status) 提取子进程退出信号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">	wait(): on success, returns the process ID of the terminated child; on error, -1 is returned.</span><br></pre></td></tr></table></figure>

<p>成功返回子进程pid，否则返回-1</p>
<h4 id="2-5-waitpid"><a href="#2-5-waitpid" class="headerlink" title="2.5  waitpid"></a>2.5  waitpid</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>在wait基础上，waitpid设置了额外两个参数：</p>
<p>pid：</p>
<ul>
<li>-1 等待任意子进程</li>
<li>0 等待子进程的进程组id等于父进程id</li>
<li>大于0 等待指定pid的子进程</li>
</ul>
<p>option：</p>
<ul>
<li>0 阻塞等待进程状态改变</li>
<li>WNOHANG  非阻塞等待进程状态改变</li>
<li>WCONTINUED 阻塞等待进程收到SIGCONT信号</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>    waitpid(): on success, returns the process ID of the child whose state has changed; if WNOHANG was specified  and  one  or  more<br>       child specified by pid exist, but have not yet changed state, then 0 is returned.  On error, -1 is returned.</p>
</blockquote>
<p>如果有子进程状态改变并等待成功，返回子进程pid。如果option参数设置的WNOHANG，并且存在子进程，但没有子进程状态改变，返回0，否则返回-1.</p>
<p>以下是一个使用waipid的简单示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是子进程 pid:&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status =<span class="number">0</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid ==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是父进程 pid:&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep (<span class="number">15</span>);</span><br><span class="line">    waitpid(pid,&amp;status,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;status:&quot;</span>&lt;&lt;WEXITSTATUS(status)&lt;&lt;<span class="string">&quot;signal:&quot;</span>&lt;&lt;WTERMSIG(status)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，在主进程中sleep（15）后再执行waitpid释放资源，子进程退出后没有被回收时，就会处于“zombie”状态。</p>
<p>通过监控脚本来检测进程状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while :;do ps ajx | head -1 &amp;&amp; ps ajx | grep test| grep -v grep;sleep 1; echo &quot;########################&quot;; done</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>如图所示，子进程8682退出后没被操作系统回收前，状态为Z+</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.6.png"></p>
<p>执行完waitpid后，子进程资源被操作系统回收：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.7.png"></p>
<h2 id="3-进程间通信"><a href="#3-进程间通信" class="headerlink" title="3. 进程间通信"></a>3. 进程间通信</h2><h3 id="3-1-管道"><a href="#3-1-管道" class="headerlink" title="3.1 管道"></a>3.1 管道</h3><blockquote>
<p>In Linux, a pipe is a form of interprocess communication that enables data to be transferred between two processes. A pipe is a unidirectional data channel, which means data can flow only in one direction, from the output of one process to the input of another.</p>
</blockquote>
<p>管道是Linux中的一种使用缓冲区的进程间通信的方式。管道是单向数据通道，意味着数据只能在一个方向上传递，从一个进程的输出到一个进程的输入.</p>
<p>我们在shell命令行中常用的 “ |” 就是管道命令。下面的示例中，将ps进程的输出通过管道传输给grep进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ajx | grep server</span><br></pre></td></tr></table></figure>

<p>Linux中有两种管道创建方式</p>
<ul>
<li>匿名管道</li>
<li>命名管道</li>
</ul>
<h4 id="3-1-1-匿名管道"><a href="#3-1-1-匿名管道" class="headerlink" title="3.1.1 匿名管道"></a>3.1.1 匿名管道</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION</p>
<p>The array pipefd is used to return two file descriptors referring to the ends of the pipe. pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of the pipe. Data written to the write end of the pipe is buffered by the kernel until it is read from the read end of the pipe.</p>
</blockquote>
<ul>
<li>pipefd是输出型参数，调用pipe后，内核分别以读和写的方式打开同一个文件，将两次打开的文件描述符填入到数组中</li>
<li>pipefd[0]是读端文件描述符，pipefd[1]是写端文件描述符</li>
</ul>
<p><strong>通过写端写入的数据会放在Linux内核的缓冲区中，而不是文件里提供的语言级I&#x2F;O 缓冲区</strong>，直到写端读取数据，才会清理缓冲区</p>
<p>下面是Linux内核中匿名管道缓冲区的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>页面是操作系统管理物理内存的基本单位，它通常是4KB或8KB大小的连续内存块。struct page是用来管理页面的结构体，它存储了页面的状态和属性。每一个struct pipe_buffer对象就对应一个页面。当我们使用管道进行通信的时候，会先将写端进程地址空间里的缓冲区的数据通过page指针访问页面然后拷贝到页面中，offset和len就会记录数据的偏移量和长度，然后读端就可以通过page指针和offset和len去访问页面中的这段数据，拷贝到读端进程空间缓冲区。</p>
<p>因为管道是单向数据通道，我们在使用pipe进行父子进程间通信，需要在父子进程中分别关闭读写的某一端，防止出现读写的错误</p>
<ul>
<li>如果是父进程向子进程发送数据：关闭父进程的读端，关闭子进程的写端</li>
<li>如果是子进程向父进程发送数据：关闭父进程的写端，关闭子进程的读端</li>
</ul>
<p>以下是一个简单示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipefd);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">20</span>]=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        write(pipefd[<span class="number">1</span>],buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;pid: &quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot; write:&quot;</span>&lt;&lt;buffer&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        read(pipefd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;pid: &quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot; read:&quot;</span>&lt;&lt;buf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(waitpid(pid,&amp;status,<span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;status: &quot;</span>&lt;&lt;WEXITSTATUS(status)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;wait err\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.9.png"></p>
<p>上述示例中，父进程创建匿名管道后fork创建子进程，子进程会复制父进程的进程控制块task_struct中的文件信息file_struct:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span><span class="comment">//文件数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的fd_array就是文件指针数组，里面的指针就指向了进程打开的文件表。所以子进程的文件指针数组指向了父进程打开的文件表，其中就包括管道文件(如果你对以上文件知识有疑惑，请阅读<a target="_blank" rel="noopener" href="https://blog.musnow.top/posts/2864480005/">Linux文件系统</a>)，所以父子进程就可以通过同一个管道文件进行通信。当父进程调用write向内核缓冲区写入数据时，内核就会通知子进程区读取数据</p>
<ul>
<li>当内核管道缓冲区为空时，read接口会阻塞等待write接口写入数据</li>
<li>当内核管道缓冲区写满时，wtire接口会阻塞等待read接口读取数据</li>
</ul>
<p>这个同步&#x2F;阻塞机制是Linux管道文件中自带的。内核中是通过等待队列来实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nrbufs, curbuf;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> waiting_writers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">bufs</span>[<span class="title">PIPE_BUFFERS</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等待队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span> lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>文件系统提供了用户级的I&#x2F;O 缓冲区，为什么还要专门使用内核级的管道缓冲区呢？</strong></p>
<ul>
<li>隔离性：内核级别的缓冲区保证了管道通信数据不会泄露到其他进程，从而提供了较好的隔离性。这使得数据在进程间传输时具有更高的安全性和可靠性。</li>
<li>同步和阻塞：内核级别的缓冲区允许管道在特定条件下进行同步和阻塞。例如，当管道为空时，读取操作会阻塞；当管道满时，写入操作会阻塞。这种特性有助于在进程间实现简单的同步和协作。</li>
<li>数据持久性：内核级别的缓冲区可以确保在进程终止时数据不会丢失。例如，当一个进程在管道中写入数据后终止，另一个进程仍然可以从管道中读取这些数据。</li>
<li>通用性：由于管道是一种通用的进程间通信机制，因此内核级别的缓冲区可以确保不同进程之间无需考虑底层实现细节就能进行通信。</li>
</ul>
<h4 id="3-1-2-命名管道"><a href="#3-1-2-命名管道" class="headerlink" title="3.1.2 命名管道"></a>3.1.2 命名管道</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       mkfifo()  makes a FIFO special file with name pathname.  mode specifies the FIFO’s permissions.  It is modified by the process’s<br>       umask in the usual way: the permissions of the created file are (mode &amp; ~umask).</p>
<p>​	A FIFO special file is similar to a pipe, except that it is created in a different way.  Instead of being an anonymous  communications channel, </p>
<p>​		a FIFO special file is entered into the file system by calling mkfifo().</p>
</blockquote>
<ul>
<li>pathname  以文件系统的方式指定管道文件名</li>
<li>mode 以文件系统的方式指定管道文件权限</li>
</ul>
<p>命名管道和匿名管道有以下区别：</p>
<ul>
<li>命名管道是通过文件系统中的文件名来访问的，而匿名管道不存在对应的文件，只存在于内存中，无法在文件系统中访问。</li>
<li>命名管道可以在进程间传递数据，即使它们没有任何关系，只要它们能够访问同一个文件系统。而匿名管道只有通过 fork() 系统调用创建出来的父子进程之间可以使用匿名管道通信。</li>
<li>命名管道具有持久性，即使所有使用该管道的进程都退出，命名管道仍然存在于文件系统中，直到显式地删除它。而匿名管道是暂时性的，只存在于相关进程运行期间。</li>
</ul>
<p>以下是服务端和多进程客户端使用命名管道文件通信的简单示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server.cc</span><br><span class="line">  <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">  <span class="number">4</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">  <span class="number">5</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">  <span class="number">6</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">  <span class="number">7</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="keyword">define</span> FIFONAME <span class="string">&quot;fifo&quot;</span></span></span><br><span class="line">  <span class="number">9</span> </span><br><span class="line"> <span class="number">10</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> 11 &#123;</span><br><span class="line"> <span class="number">12</span>     mkfifo(FIFONAME,<span class="number">0666</span>);</span><br><span class="line"> <span class="number">13</span>     <span class="type">int</span> fd = open(FIFONAME,O_RDONLY);</span><br><span class="line"> <span class="number">14</span>     <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line"> <span class="number">15</span>     &#123;   </span><br><span class="line"> <span class="number">16</span>         <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> <span class="number">17</span>         <span class="type">size_t</span> s =read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"> <span class="number">18</span>         <span class="keyword">if</span>(s &gt; <span class="number">0</span>)</span><br><span class="line"> <span class="number">19</span>         &#123;</span><br><span class="line"> <span class="number">20</span>             <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line"> <span class="number">21</span>         &#125;</span><br><span class="line"> <span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="number">0</span>)</span><br><span class="line"> <span class="number">23</span>         &#123;</span><br><span class="line"> <span class="number">24</span>             <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">25</span>         &#125;</span><br><span class="line"> <span class="number">26</span>     &#125;</span><br><span class="line"> <span class="number">27</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">client.cc</span><br><span class="line">  <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">  <span class="number">4</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">  <span class="number">5</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">  <span class="number">6</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">  <span class="number">7</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="keyword">define</span> FIFONAME <span class="string">&quot;fifo&quot;</span></span></span><br><span class="line">  <span class="number">9</span> </span><br><span class="line"> <span class="number">10</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> 11 &#123;</span><br><span class="line"> <span class="number">12</span>     fork();</span><br><span class="line"> <span class="number">13</span>     <span class="type">char</span> info[<span class="number">20</span>]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"> <span class="number">14</span>     <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"> <span class="number">15</span>     <span class="type">int</span> fd = open(FIFONAME,O_WRONLY);</span><br><span class="line"> <span class="number">16</span>     <span class="built_in">sprintf</span>(buf,<span class="string">&quot;ppid:%d pid:%d write:%s \n&quot;</span>,getppid(),getpid(),info);                                    <span class="number">17</span>     write(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"> <span class="number">18</span>     wait(nullptr);</span><br><span class="line"> <span class="number">19</span> &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.0.png"></p>
<h3 id="3-2-共享内存"><a href="#3-2-共享内存" class="headerlink" title="3.2 共享内存"></a>3.2 共享内存</h3><p>共享内存是一种进程间通信的机制，它允许不同进程之间共享同一段物理内存区域，以达到高效传递大量数据的目的。在 Linux 系统中，共享内存由系统内核维护，使用时需要调用相应的系统调用，包括 <code>shmget()</code>、<code>shmat()</code>、<code>shmdt()</code>、<code>shmctl()</code>、<code>ftok()</code> 等.</p>
<p><strong>共享内存和管道的区别：</strong></p>
<ul>
<li>共享内存直接访问内存，而管道需要通过内核缓冲区进行数据的拷贝，因此共享内存具有传输速度快、效率高的优点.</li>
<li>共享内存是直接访问内存，因此不适合用于传输敏感数据，需要应用层自行实现锁机制等保护机制以确保数据的安全性.</li>
<li>共享内存没有访问控制，需要用户设置访问控制，例如信号量.</li>
</ul>
<p>为了实现进程间通信，让不同进程间能访问到同一块内存，共享内存的实现机制类似于命名管道让用户自己指定管道文件路径，提供了<code>ftok()</code>接口让用户自己生成共享内存的编号.</p>
<h4 id="3-2-1-ftok"><a href="#3-2-1-ftok" class="headerlink" title="3.2.1 ftok"></a>3.2.1 ftok</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>pathname是工作文件路径</li>
<li>proj_id是你的当前工程的编号（非0，至少8位）</li>
</ul>
<blockquote>
<p>DESCRIPTION<br>       The  ftok() function uses the identity of the file named by the given pathname (which must refer to an existing, accessible file) and the least significant 8 bits of proj_id (which must be nonzero) to generate a key_t type System V IPC key</p>
</blockquote>
<p>ftok会根据你提供的两个参数生成一个内存空间的key，用户就可以通过这个key去申请内存空间.</p>
<h4 id="3-2-2-shmget"><a href="#3-2-2-shmget" class="headerlink" title="3.2.2 shmget"></a>3.2.2 shmget</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>key 就是ftok生成的内存空间key</li>
<li>size是内存空间大小，应为4Kb的整数倍，因为系统I&#x2F;O的基本单位是4Kb，否则会出现内存空间浪费的情况</li>
<li>shmflg是创建共享内存的方式</li>
</ul>
<p><code>IPC_CREAT:</code>创建共享内存。如果存在则获取，如果不存在则创建后获取</p>
<p><code>IPC_EXCL: </code>必须配合IPC_CREAT使用，如果不存在指定的共享内存，就进行创建；如果该共享内存存在，则出错返回（即保证获取到的共享内存一定是当前进程创建的，是一个新的共享内存）</p>
<p>返回值：</p>
<blockquote>
<p>RETURN VALUE<br>       On success, a valid shared memory identifier is returned.  On errir, -1 is returned, and  errno  is  set  to  indicate  the</p>
<p>error.</p>
</blockquote>
<p><code>shmget</code>会帮我们在内存上开辟出一段空间，如果成功返回这块内存空间的唯一标识符，否则返回-1.</p>
<h4 id="3-2-3-shmat-x2F-shmdt"><a href="#3-2-3-shmat-x2F-shmdt" class="headerlink" title="3.2.3 shmat&#x2F;shmdt"></a>3.2.3 shmat&#x2F;shmdt</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>shmid  shmget返回的内存空间标识符</li>
<li>shmaddr 指定共享内存连接到当前进程中的地址位置。通常为空，表示让系统来选择共享内存的地址</li>
<li>shmflg 使用共享内存的方式，一般设置为0,默认以读写打开</li>
</ul>
<p>返回值：</p>
<blockquote>
<p>RETURN VALUE<br>       On  success shmat() returns the address of the attached shared memory segment; on<br>       error (void *) -1 is returned, and errno is set to  indicate  the  cause  of  the<br>       error.</p>
</blockquote>
<p><code>shmat</code>会将共享内存空间和我们的进程关联起来，将这段共享内存通过页表映射到我们的进程地址空间上，我们将需要通信的进程分别和这块共享内存进行关联，就可以在各自的进程中使用同一块内存空间进行通信.如果创建成功就返回这块内存的起始地址.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>shmaddr就是shmat的返回值</li>
</ul>
<blockquote>
<p>RETURN VALUE</p>
<p>​		On success shmdt() returns 0; on error -1 is returned, and errno is set to indicate the cause of the error.</p>
</blockquote>
<p>shmdt就是解除进程和共享内存的关联</p>
<h4 id="3-2-4-shmctl"><a href="#3-2-4-shmctl" class="headerlink" title="3.2.4 shmctl"></a>3.2.4 shmctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>shmid 内存空间的唯一标识符</li>
<li>buf 一般设置为NULL</li>
<li>cmd是操作类型</li>
</ul>
<p><code>IPC_RMID：</code>删除共享内存</p>
<p><code>IPC_STAT：</code>把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值</p>
<p><code>IPC_SET：</code>如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值、</p>
<p>shmid_ds结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uid_t</span> shm_perm.uid;</span><br><span class="line">    <span class="type">uid_t</span> shm_perm.gid;</span><br><span class="line">    <span class="type">mode_t</span> shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是一个创建共享内存的简单示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PATHNAME <span class="string">&quot;/home/wyj/test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key =ftok(PATHNAME,<span class="number">2107120119</span>);</span><br><span class="line">    <span class="type">int</span> id =shmget(key,<span class="number">4096</span>,IPC_CREAT | IPC_EXCL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过ipc命令查看开辟的共享内存空间:</p>
<blockquote>
<p>ipcs -c #查看消息队列&#x2F;共享内存&#x2F;信号量<br>ipcs -s #单独查看信号量<br>ipcs -q #单独查看消息队列<br>ipcs -m #单独查看共享内存</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcs -m </span><br></pre></td></tr></table></figure>

<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.1.png"></p>
<p>进程关联共享内存后，进行通信：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server.cc</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHNAME <span class="string">&quot;/home/wyj/test&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PATHNAME, <span class="number">2107120119</span>);</span><br><span class="line">    <span class="type">int</span> id = shmget(key, <span class="number">4096</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> *addr = (<span class="type">int</span> *)shmat(id, nullptr, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; addr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    shmdt(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">client.cc</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHNAME <span class="string">&quot;/home/wyj/test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PATHNAME, <span class="number">2107120119</span>);</span><br><span class="line">    <span class="type">int</span> id = shmget(key, <span class="number">4096</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> *addr = (<span class="type">int</span> *)shmat(id, nullptr, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        addr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.2.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-线程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/26/%E7%BA%BF%E7%A8%8B/"
    >Linux下多线程编程及pthread库的使用</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/26/%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2023-04-25T16:00:00.000Z" itemprop="datePublished">2023-04-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-Linux下的线程"><a href="#1-Linux下的线程" class="headerlink" title="1. Linux下的线程"></a>1. Linux下的线程</h2><h4 id="1-1-Linux下线程与进程的关系"><a href="#1-1-Linux下线程与进程的关系" class="headerlink" title="1.1 Linux下线程与进程的关系"></a>1.1 Linux下线程与进程的关系</h4><ul>
<li><p><strong>进程是操作系统分配资源的基本单位</strong></p>
</li>
<li><p><strong>线程是操作系统任务调度的基本单位</strong></p>
</li>
<li><p><strong>Linux内核中的线程可以看作是轻量级进程</strong></p>
</li>
<li><p><strong>进程具有独立性，线程不具有独立性</strong></p>
<p>我们知道，Linux内核在创建<strong>进程</strong>时：</p>
<ol>
<li>创建并初始化<strong>进程控制块 PCB（Process Control Block）</strong>：它记录了进程的状态、标识符、优先级等。</li>
<li>为进程分配独立的虚拟进程地址空间，将程序、数据、库文件载入虚拟地址空间中。</li>
<li>复制父进程的内存空间：因为Linux采取了<strong>写时拷贝COW（Copy-On-Write）</strong>的技术，该进程的内存页表是父进程内存页表的一份拷贝，只有子进程需要修改其中某个内存页时，子进程的内存页表才会重新建立内存页表到物理空间的映射</li>
<li>复制父进程的文件描述符表</li>
<li>复制父进程的环境变量和命令行参数</li>
<li>复制父进程的信号处理器</li>
</ol>
<p>而Linux内核在创建<strong>线程</strong>时：</p>
<p>  1.初始化线程控制块（Thread Control Block，TCB）</p>
<p>  2.设置线程的堆栈、寄存器</p>
<p>  3.设置线程的调度属性</p>
<p>  4.加入到进程的线程组中，这些线程共享进程的部分资源</p>
<p>这些创建出来的线程不创建地址空间，而是<strong>共享进程的地址空间和其他资源</strong>（文件描述符，信号处理器等），其创建的开销远小于进程，所以我们说Linux下线程可以看作是轻量级进程。</p>
<p>进程拥有自己独立的进程地址空间，进程具有独立性，而线程共享进程的地址空间，所有线程不具有独立性。线程除了共享进程地址空间，也拥有自己的私有成员：线程标识符、线程栈、线程寄存器</p>
<p><strong>线程栈和线程寄存器是线程的两个重要组成部分：</strong></p>
<ul>
<li>线程栈是一个特殊的内存区域，用于存储线程执行时的函数调用栈、局部变量、函数参数等数据。每个线程都有自己的线程栈，线程栈的大小在创建线程时可以指定。线程在执行过程中，会不断地向线程栈中压入和弹出函数调用的相关信息，从而实现程序的正常执行。</li>
<li>线程寄存器是CPU中的一组特殊寄存器，用于存储线程执行时的上下文信息，包括程序计数器、栈指针、通用寄存器等。线程在执行过程中，需要不断地保存和恢复这些寄存器的值，以便在线程切换时保持线程的执行状态。</li>
</ul>
<p>在Linux系统中，线程栈和线程寄存器是由内核进行管理和调度的。线程栈和线程寄存器的分配和初始化工作是由内核在创建线程时完成的，当线程被切换时，内核会将线程栈和线程寄存器中的内容保存下来，然后切换到其他线程的执行上下文。因此，线程栈和线程寄存器的正确使用和管理对于线程的正常运行至关重要。</p>
</li>
</ul>
<h4 id="1-2-Linux下线程的种类"><a href="#1-2-Linux下线程的种类" class="headerlink" title="1.2  Linux下线程的种类"></a>1.2  Linux下线程的种类</h4><ol>
<li>用户级线程（User-Level Thread，ULT）：这种线程是由用户空间的线程库（<strong>如 pthread库</strong>）实现的，线程的创建、调度、同步等都由线程库管理。内核对用户级线程是没有感知的，因此它们的调度和同步都是由用户空间的线程库完成的。由于用户级线程不需要进入内核空间，因此它们的切换比内核级线程快，但是它们无法利用多处理器。</li>
<li>内核级线程（Kernel-Level Thread，KLT）：这种线程由内核创建和管理，它们的调度和同步都是由内核完成的。内核级线程可以利用多处理器，但是它们的切换比用户级线程慢。Linux 中的内核级线程是使用轻量级进程实现的，每个进程都可以拥有多个轻量级进程，也就是说，一个进程可以拥有多个内核级线程。</li>
</ol>
<h2 id="2-pthread库的使用"><a href="#2-pthread库的使用" class="headerlink" title="2. pthread库的使用"></a>2. pthread库的使用</h2><p>pthread是官方提供的用户级的线程库，我们口中所指的线程大多就是指phread库为我们提供的用户级线程。</p>
<h4 id="2-1-头文件"><a href="#2-1-头文件" class="headerlink" title="2.1 头文件"></a>2.1 头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> <span class="comment">// 头文件 Linux系统默认带pthread库</span></span></span><br></pre></td></tr></table></figure>

<p>pthread不属于标准库，编译时需要带上 -lpthread</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cc -o test -lpthread</span><br></pre></td></tr></table></figure>

<h4 id="2-2-pthread-create"><a href="#2-2-pthread-create" class="headerlink" title="2.2 pthread_create"></a>2.2 pthread_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION</p>
<p>​	   The  pthread_create()  function  starts  a new thread in the calling process</p>
</blockquote>
<p>这个接口会在当前进程中创建出一个用户级线程</p>
<ul>
<li>第一个参数是线程的id</li>
<li>第二个参数是线程的属性，一般设置为nullptr</li>
<li>第三个参数是函数指针，这个函数的返回值是void*  ，参数为void* ，创建出来的线程会去执行这个函数</li>
<li>第四个参数是start_routine函数传给线程的参数</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>       On success, pthread_create() returns 0; on error, it returns an error number, and the contents of *thread are undefined.</p>
</blockquote>
<p>创建成功时，返回值为0，创建失败返回错误码。</p>
<h4 id="2-3-pthread-join"><a href="#2-3-pthread-join" class="headerlink" title="2.3 pthread_join"></a>2.3 pthread_join</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       The  pthread_join() function waits for the thread specified by thread to terminate.  If that thread has already terminated, then pthread_join() returns immediately.  </p>
<p>​	   The thread specified by thread must be joinable.</p>
</blockquote>
<p>这个接口会一直阻塞等待目标线程执行完毕后回收资源，如果线程已经被回收，会直接返回。</p>
<p>The thread specified by thread must be joinable. 意思是这个线程必须是joinable属性（创建线程时不指定属性的话默认是joinable）或者没有被显式的剥离（调用pthread_detach)。</p>
<p>由于线程占用的资源不会在线程执行完时自己释放，所以需要其他线程执行pthread_join（或者同时调用pthread_detach和pthread_exit)来释放资源，否则就会导致资源的泄露。</p>
<ul>
<li>第一个参数是等待的线程id</li>
<li>第二个参数可以接收等待的线程执行完毕后的返回值</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>       On success, pthread_join() returns 0; on error, it returns an error number.</p>
</blockquote>
<p>等待成功返回0，否则返回错误码</p>
<p>以下是一个简单的线程创建和等待回收的示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;run&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;t,nullptr,run,nullptr) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;pthread_create error\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞等待线程回收</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_join(t,nullptr) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;pthread_join success\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM-20-8-centos ]$ g++ test.cc -o test -lpthread -std=c++11</span><br><span class="line">[wyj@VM-20-8-centos ]$ ./test</span><br><span class="line">run</span><br><span class="line">pthread_join success</span><br></pre></td></tr></table></figure>

<h4 id="2-3-pthread-exit"><a href="#2-3-pthread-exit" class="headerlink" title="2.3 pthread_exit"></a>2.3 pthread_exit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       The  pthread_exit()  function  terminates  the calling thread and returns a value via retval that (if the thread is joinable) is<br>       available to another thread in the same process that calls pthread_join</p>
</blockquote>
<p>这个接口可以终止运行的线程，进程中其他没有被剥离（调用pthread_detach)的线程可以通过pthread_join接收这个被终止线程的返回值</p>
<ul>
<li>参数retval的值可以被其他线程通过pthread_join获取</li>
</ul>
<p>Linux下线程结束执行有以下几种情况:</p>
<ul>
<li>线程将指定函数体中的代码执行完后自行结束；</li>
<li>线程执行过程中，被同一进程中的其它线程（包括主线程）强制终止；</li>
<li>线程执行过程中，遇到 pthread_exit() 函数结束执行。</li>
</ul>
<p>下面给出几个简单的使用示例：</p>
<p><strong>通过pthread_exit退出线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_exit(<span class="string">&quot;pthread_exit&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line">    <span class="comment">// 阻塞等待线程回收</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(t, &amp;ret) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;pthread_join success\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span>*)ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ ./test</span><br><span class="line">pthread_join success</span><br><span class="line">pthread_exit</span><br></pre></td></tr></table></figure>

<p>由结果可知，线程调用pthread_exit后提前退出，没有执行后面的printf(“run\n”)，主线程通过pthread_join获得退出值</p>
<p><strong>强制退出线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM-20-8-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM-20-8-centos]$ ./test</span><br><span class="line">main thread exit</span><br></pre></td></tr></table></figure>

<p>由执行结果可知，创建出来的线程并没有执行run函数，这是因为本次运行，cpu的调度使得主线程先执行，而且主线程并没有调用pthread_join去阻塞等待子线程，当主线程执行return 0的时候会调用系统接口exit(), exit()会终止进程内的所有线程，所以子线程没有执行run函数就被强制退出了。</p>
<p>如果我们用pthread_exit提前退出主线程，不执行return 0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ ./test</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>由结果可知，主线程提前退出，没有执行return 0，子线程执行了run函数。pthread_exit退出当前线程，不会影响其他线程。</p>
<p><strong>此外，pthread_exit() 可以自动调用线程清理程序（本质是一个由 pthread_cleanup_push() 指定的自定义函数），return 则不具备这个能力。总之在实际场景中，如果想终止某个子线程执行，强烈建议大家使用 pthread_exit() 函数。</strong></p>
<h4 id="2-4-pthread-detach"><a href="#2-4-pthread-detach" class="headerlink" title="2.4 pthread_detach"></a>2.4 pthread_detach</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       The  pthread_detach()  function  marks  the  thread  identified  by  thread as detached.  When a detached thread terminates, its<br>       resources are automatically released back to the system without the need for another thread to join with the terminated thread.</p>
</blockquote>
<p>这个接口会将线程的状态设置为detached，当这个线程执行结束时，资源会被操作系统自动回收，不需要使用者手动调用pthread_join来回收。</p>
<ul>
<li>参数为线程的id</li>
</ul>
<p>我们知道，如果一个线程执行结束但还没有被join时，他的状态类似与进程中的僵尸进程（Zombie Process），需要创建线程的人手动调用pthread_join阻塞回收资源。</p>
<p>但有时我们并不想阻塞等待，导致效率降低，同时为了避免资源泄露，就可以使用pthread_detach，让操作系统替我们管理线程。</p>
<p>通常，在剥离子线程时，我们会让主线程保持在后台运行（常驻内存的程序），从而避免主线程退出，操作系统就自动回收被剥离的子线程，从而避免子线程还未执行完就退出的问题。</p>
<h4 id="2-5-gettid"><a href="#2-5-gettid" class="headerlink" title="2.5 gettid"></a>2.5 gettid</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t gettid(void);</span><br></pre></td></tr></table></figure>

<p>头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       gettid()  returns the caller’s thread ID (TID).  In a single-threaded process, the thread ID is equal to the process ID (PID, as<br>       returned by getpid().  In a multithreaded process, all threads have the same PID, but each one has a unique TID.</p>
</blockquote>
<p>gettid可以获取当前线程的线程tid，当进程内只有一个线程的时候，线程的tid等于进程的pid</p>
<p><strong>gettid是系统接口，需要通过syscall来调用</strong></p>
<h4 id="2-6-syscall"><a href="#2-6-syscall" class="headerlink" title="2.6 syscall"></a>2.6 syscall</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall</span><span class="params">(<span class="type">int</span> number, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span>   <span class="comment">/* For SYS_xxx definitions */</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>syscall()  is  a  small library function that invokes the system call whose assembly language interface has the specified number with the specified arguments.  Employing syscall() is useful, for example, when invoking a system call that has no wrapper function in the C library.</p>
<p>syscall() saves CPU registers before making the system call, restores the registers upon return from the system call, and stores any error code returned by the system call in errno if an error occurs.</p>
</blockquote>
<p>sycall()是一个小型库函数，它调用系统调用，其汇编语言接口具有指定编号和指定参数。例如，当调用C库中没有包装器函数的系统调用时，使用sycall()是有用的。</p>
<p>syscall()在进行系统调用之前保存CPU寄存器，在系统调用返回时恢复寄存器，并存储error中的错误码</p>
<p>以下是一个简单示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> tid;</span><br><span class="line"></span><br><span class="line">    tid = syscall(SYS_gettid);</span><br><span class="line">    tid = syscall(SYS_tgkill, getpid(), tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-线程互斥"><a href="#3-线程互斥" class="headerlink" title="3.线程互斥"></a>3.线程互斥</h2><h4 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h4><p>线程互斥是指在多个线程中，对同一临界资源的访问进行限制，保证同一时间只有一个线程能够访问该资源，以避免多个线程同时修改同一个资源而导致的数据不一致问题。</p>
<h4 id="3-2-临界资源"><a href="#3-2-临界资源" class="headerlink" title="3.2 临界资源"></a>3.2 临界资源</h4><p>临界资源是指共享的一段代码、一组数据或一块内存区域等，他们能被多个线程访问、修改，所以需要通过互斥访问来保证数据一致性的资源。比如，在一个多线程程序中，多个线程可能同时访问同一份数据结构，这时就需要使用临界资源的互斥访问来保证数据的正确性。</p>
<h4 id="3-3-锁"><a href="#3-3-锁" class="headerlink" title="3.3 锁"></a>3.3 锁</h4><p><strong>锁是一种解决多线程访问临界资源的冲突一种技术。</strong>锁的实现依赖于操作系统的调度和底层硬件的原子性操作。</p>
<h4 id="3-4-pthread-mutex"><a href="#3-4-pthread-mutex" class="headerlink" title="3.4 pthread_mutex"></a>3.4 pthread_mutex</h4><p>pthread_mutex是pthread库中实现的互斥锁，他的实现依赖于futex（fast userspace mutex）系统调用，它是一个基于用户空间和内核空间的协同机制，主要作用是将用户空间的线程挂起等待某个事件发生，并在事件发生时唤醒他们。futex底层实现中涉及到CPU提供的原子操作.</p>
<p>当一个线程想要加锁时，它会首先尝试在用户空间中使用原子操作（如CAS）来获取锁，如果获取成功，则直接返回；否则，线程会调用futex_wait函数挂起自己，并在内核中等待锁的释放。当锁被持有线程释放时，它会调用futex_wake函数唤醒等待的线程，使它们重新竞争锁。在这个过程中，操作系统内核会对锁进行一些状态的维护，例如是否有线程正在等待锁、锁的拥有者等等。</p>
<p>以下是X86架构CPU加锁过程汇编指令的简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock:</span><br><span class="line">    mov eax, 1   ; 将eax寄存器设置为1</span><br><span class="line">    xchg eax, [lock] ; 将eax寄存器中的值与lock变量中的值进行交换，lock变量中的值变为1</span><br><span class="line">    test eax, eax   ; 测试eax寄存器的值是否为0，为0则代表有锁资源</span><br><span class="line">    jnz lock    ; 如果eax寄存器的值不为0，跳转到lock标签处，继续尝试获取锁</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>lock初始化值为0,0代表有锁资源，1代表无锁资源</li>
<li>在单处理机中，一次只有一个线程能上处理机执行xchg指令，是原子性操作</li>
<li>实际的锁实现会更加复杂，涉及到缓存一致性、总线锁定等底层细节。</li>
</ul>
<p>以下是pthread库提供的关于锁操作的接口：</p>
<p><strong>锁变量：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> </span><br></pre></td></tr></table></figure>

<p><strong>初始化锁：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span><br><span class="line">       				   const pthread_mutexattr_t *restrict attr)</span><br><span class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>pthread库提供了两种初始化锁的方式：</p>
<ul>
<li>通过init接口，第二个参数可以设置锁的属性</li>
<li>通过宏 PTHREAD_MUTEX_INITIALIZER只能创建用于静态内存的锁，即在定义时直接声明的变量</li>
</ul>
<p><strong>加锁：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread库提供了两种加锁方式：</p>
<ul>
<li>lock是阻塞式加锁</li>
<li>unlock是非阻塞式加锁</li>
</ul>
<p><strong>解锁：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure>

<p><strong>释放锁：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>以下是不加锁情况下多线程访问临界资源的简单实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">10000</span>; <span class="comment">// 临界区资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">run</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt;<span class="string">&quot;tid：&quot;</span>&lt;&lt;<span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; --count &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, run, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，创建了3个线程去并发执行run函数，count是临界区资源，三个线程都可以访问修改count。</p>
<p>执行结果：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/1.png"></p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/1.1.png"></p>
<p>出现了各种输出错误和数据不一致，这是多线程访问临界资源导致的冲突情况。</p>
<p>以下是加锁以后的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1000</span>; <span class="comment">// 临界区资源</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">run</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">200</span>);</span><br><span class="line">            std::cout &lt;&lt;<span class="string">&quot;tid：&quot;</span>&lt;&lt;<span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; --count &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pthread_mutex_init(&amp;mutex,nullptr);</span></span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, run, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/2.png"></p>
<p>通过加锁解决了多线程访问临界资源冲突的问题。但是通过tid可以看出，整个进程生命周期里，<strong>几乎只有单个线程在执行任务</strong>，并不是我们预期设想的多个线程并发执行任务。</p>
<p>产生这种现象的原因：该线程执行任务的消耗小于CPU切换到其他线程的消耗，所以CPU调度机制会保持该线程运行下去，不会切换线程。这样就会导致其他线程创建出来却没有执行任务，反而浪费了系统的资源，为了解决这个问题，我们引入了<strong>线程同步</strong>。</p>
<h2 id="4-线程同步"><a href="#4-线程同步" class="headerlink" title="4. 线程同步"></a>4. 线程同步</h2><p>当我们对多线程互斥访问同一份资源不作限制时，完全由CPU去进行调度，就有可能会出现上面的线程饥饿现象，导致资源的浪费，因此我们引入了线程同步的概念，在保证线程访问安全的前提下，通过条件变量等机制去控制线程，使得多个线程能够按照一定的顺序、时间和方式执行。</p>
<h4 id="4-1-条件变量"><a href="#4-1-条件变量" class="headerlink" title="4.1 条件变量"></a>4.1 条件变量</h4><p>以下是pthread库提供的条件变量接口：</p>
<p><strong>条件变量：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化：</strong></p>
<p>类似于锁，pthread库提供了两种初始化条件变量方式：</p>
<ul>
<li>init接口，第二个参数可以设置条件变量属性</li>
<li>通过宏 PTHREAD_COND_INITIALIZER只能创建用于静态内存的锁，即在定义时直接声明的变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;              		  </span><br></pre></td></tr></table></figure>

<p><strong>等待条件变量信号：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_timedwait(pthread_cond_t *restrict cond,</span><br><span class="line">              pthread_mutex_t *restrict mutex,</span><br><span class="line">              const struct timespec *restrict abstime);</span><br><span class="line">int pthread_cond_wait(pthread_cond_t *restrict cond,</span><br><span class="line">              pthread_mutex_t *restrict mutex);</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数为条件变量，第二个参数为锁，目的是<strong>保证条件变量读写的原子性</strong></li>
<li>timedwait接口的多出的第三个参数可以设置等待的时间</li>
</ul>
<p><strong>!!! 注意，pthread库在wait和timewait内部做了类似下面的特殊处理：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">   pthread_mutex_unlock(mutex);</span><br><span class="line">    <span class="comment">// 阻塞等待条件变量信号</span></span><br><span class="line">   	 ...</span><br><span class="line">    <span class="comment">// 收到条件变量信号，如果有锁资源，加锁，没有锁资源，阻塞等待加锁</span></span><br><span class="line">   pthread_mutex_lock(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行条件变量信号等待时，会先进行解锁，阻塞等待条件变量信号，直到收到信号才会进行加锁。<strong>这样处理的目的是防止线程阻塞时占用锁资源，使得其他线程没法及时获得锁资源。</strong></p>
<p>这种特殊处理会导致使用条件变量时出现下面的情况：</p>
<p>收到条件变量信号的某个线程加锁后开始执行任务，其他线程的状态为阻塞等待条件变量信号或者阻塞等待锁资源，但假如拿到锁的线程退出后没有释放锁，就会导致其他线程一只阻塞等待阻塞等待加锁。</p>
<p><strong>为了避免这种情况的发生，需要程序员在程执行完后手动释放锁资源。</strong></p>
<p><strong>发送条件变量信号：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个接口会向所有阻塞在cond条件变量下的线程发送信号</li>
<li>第二个接口会向至少一个阻塞在cond条件变量下的线程发送信号</li>
</ul>
<h4 id="4-2-生产消费者模型–阻塞队列"><a href="#4-2-生产消费者模型–阻塞队列" class="headerlink" title="4.2 生产消费者模型–阻塞队列"></a>4.2 生产消费者模型–阻塞队列</h4><p>生产消费者是线程同步中常用的一个模型，它不仅能保证各种操作的原子性，还能实现访问控制。</p>
<p>生产消费者模型结构：</p>
<ul>
<li>任务队列：存放待执行任务的队列，</li>
<li>生产者：主线程向任务队列中添加任务并通知子线程</li>
<li>消费者：子线程从任务队列中取出任务并通知主线程</li>
</ul>
<p>通过锁来保证生产者添加任务和消费者取出任务操作的原子性，通过条件变量来控制线程。</p>
<p>下面是生产消费者模型的一个简单示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span>&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Task*&gt; queue_;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> *mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> *cond;</span><br><span class="line">    <span class="type">int</span> MaxNum;</span><br><span class="line">public:</span><br><span class="line">    TaskQueue(<span class="type">int</span> n)</span><br><span class="line">    :MaxNum(n)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(mutex,nullptr);</span><br><span class="line">        pthread_cond_init(cond,nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(Task *t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mutex);</span><br><span class="line">        <span class="keyword">if</span>(queue_.size()&gt;= MaxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(cond,mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        queue_.push(t);</span><br><span class="line">        pthread_cond_signal(cond);</span><br><span class="line">        pthread_mutex_unlock(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    Task* <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mutex);</span><br><span class="line">        <span class="keyword">if</span>(queue_.size()== <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(cond,mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        Task *t = queue_.front();</span><br><span class="line">        queue_.pop();</span><br><span class="line">        pthread_cond_signal(cond);</span><br><span class="line">        pthread_mutex_unlock(mutex);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5.线程池"></a>5.线程池</h2><p>线程池是通过<strong>池化技术</strong>实现的一种管理线程的技术栈，通过线程池技术，我们可以将线程的创建和任务的执行解耦开来，从而实现<strong>降低资源消耗</strong>、<strong>提高响应速度</strong> 、<strong>方便线程管理</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Threadpool</span>&#123;</span></span><br><span class="line">private:</span><br><span class="line">    Threadpool(<span class="type">int</span> threadNum)</span><br><span class="line">    :threadNum_(threadNum)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    Threadpool(<span class="type">const</span> Threadpool &amp;)=delete;</span><br><span class="line">    Threadpool &amp; operator =(<span class="type">const</span> Threadpool &amp;)=delete;</span><br><span class="line">    ~Threadpool();</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 获得线程池单例</span></span><br><span class="line">    <span class="type">static</span> Threadpool* <span class="title function_">GetInstance</span><span class="params">(<span class="type">int</span> threadNum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Double Check Lock</span></span><br><span class="line">        <span class="keyword">if</span>(instance == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;Mutex);</span><br><span class="line">            <span class="keyword">if</span>(instance ==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = new Threadpool(threadNum);</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;Mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务到任务队列</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">addTask</span><span class="params">(<span class="type">void</span>(*)(<span class="type">void</span>*),<span class="type">void</span> *args)</span>;</span><br><span class="line">    <span class="comment">// 添加空任务到任务队列</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">joinAll</span><span class="params">()</span>;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* <span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Task</span>&#123;</span></span><br><span class="line">        Task(<span class="type">void</span> (*func)(<span class="type">void</span>*),<span class="type">void</span> *args)</span><br><span class="line">        :args_(args)</span><br><span class="line">        ,func_(func)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *args_;<span class="comment">// 参数</span></span><br><span class="line">        <span class="type">void</span> (*func_)(<span class="type">void</span> *); <span class="comment">// 任务函数指针</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> Threadpool * instance;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Task*&gt; Taskqueue;<span class="comment">// 任务队列</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> queueMutex;<span class="comment">// 锁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> Mutex; <span class="comment">// 单例锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> queueCond;<span class="comment">// 条件变量</span></span><br><span class="line">    <span class="type">pthread_t</span> * threads; </span><br><span class="line">    <span class="type">int</span> threadNum_;<span class="comment">// 线程数量</span></span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line">Threadpool * Threadpool::instance =nullptr;</span><br><span class="line"><span class="type">pthread_mutex_t</span> Threadpool::Mutex;</span><br><span class="line"></span><br><span class="line">Threadpool::~Threadpool()</span><br><span class="line">&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    pthread_cond_broadcast(&amp;queueCond);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum_;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(threads[i],nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">    delete [] threads;</span><br><span class="line">    pthread_mutex_destroy(&amp;queueMutex);</span><br><span class="line">    pthread_cond_destroy(&amp;queueCond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">Threadpool::run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;instance-&gt;queueMutex);</span><br><span class="line">        <span class="keyword">while</span>(instance-&gt;Taskqueue.empty() &amp;&amp; !instance-&gt;stop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待线程被唤醒</span></span><br><span class="line">            pthread_cond_wait(&amp;instance-&gt;queueCond,&amp;instance-&gt;queueMutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(instance-&gt;stop)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;instance-&gt;queueMutex);</span><br><span class="line">            pthread_exit(nullptr);</span><br><span class="line">        &#125;</span><br><span class="line">        Task * task = instance-&gt;Taskqueue.front();</span><br><span class="line">        instance-&gt;Taskqueue.pop();</span><br><span class="line">        pthread_mutex_unlock(&amp;instance-&gt;queueMutex);</span><br><span class="line">        <span class="keyword">if</span>(task)</span><br><span class="line">        &#123;</span><br><span class="line">            task-&gt;func_(task-&gt;args_);</span><br><span class="line">            delete task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Threadpool::addTask</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>*),<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    Task *task= new Task(func,args);</span><br><span class="line">    pthread_mutex_lock(&amp;queueMutex);</span><br><span class="line">    Taskqueue.push(task);</span><br><span class="line">    <span class="comment">// 通知消费者消费</span></span><br><span class="line">    pthread_cond_signal(&amp;queueCond);</span><br><span class="line">    pthread_mutex_unlock(&amp;queueMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队列添加空任务</span></span><br><span class="line"><span class="type">void</span> Threadpool:: joinAll()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum_;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        addTask(nullptr,nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Threadpool::Threadpool(<span class="type">int</span> threadNum)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;threadNum_ = threadNum;</span><br><span class="line">    pthread_mutex_init(&amp;queueMutex,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;queueCond,<span class="literal">NULL</span>);</span><br><span class="line">    threads = new <span class="type">pthread_t</span>[threadNum];</span><br><span class="line">    stop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;threads[i],<span class="literal">NULL</span>,run,this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> Yun Jia
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="https://beian.miit.gov.cn/" target="_black" rel="nofollow">鄂ICP备2023006869号-1</a>
        </li>
        
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer.svg" alt="嘉禾望岗"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat%20(2).jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=2027529783&auto=1&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>