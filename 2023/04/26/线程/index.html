<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Linux下多线程编程及pthread库的使用 |  嘉禾望岗</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="嘉禾望岗" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-线程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Linux下多线程编程及pthread库的使用
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/26/%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2023-04-25T16:00:00.000Z" itemprop="datePublished">2023-04-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">5.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">23 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-Linux下的线程"><a href="#1-Linux下的线程" class="headerlink" title="1. Linux下的线程"></a>1. Linux下的线程</h2><h4 id="1-1-Linux下线程与进程的关系"><a href="#1-1-Linux下线程与进程的关系" class="headerlink" title="1.1 Linux下线程与进程的关系"></a>1.1 Linux下线程与进程的关系</h4><ul>
<li><p><strong>进程是操作系统分配资源的基本单位</strong></p>
</li>
<li><p><strong>线程是操作系统任务调度的基本单位</strong></p>
</li>
<li><p><strong>Linux内核中的线程可以看作是轻量级进程</strong></p>
</li>
<li><p><strong>进程具有独立性，线程不具有独立性</strong></p>
<p>我们知道，Linux内核在创建<strong>进程</strong>时：</p>
<ol>
<li>创建并初始化<strong>进程控制块 PCB（Process Control Block）</strong>：它记录了进程的状态、标识符、优先级等。</li>
<li>为进程分配独立的虚拟进程地址空间，将程序、数据、库文件载入虚拟地址空间中。</li>
<li>复制父进程的内存空间：因为Linux采取了<strong>写时拷贝COW（Copy-On-Write）</strong>的技术，该进程的内存页表是父进程内存页表的一份拷贝，只有子进程需要修改其中某个内存页时，子进程的内存页表才会重新建立内存页表到物理空间的映射</li>
<li>复制父进程的文件描述符表</li>
<li>复制父进程的环境变量和命令行参数</li>
<li>复制父进程的信号处理器</li>
</ol>
<p>而Linux内核在创建<strong>线程</strong>时：</p>
<p>  1.初始化线程控制块（Thread Control Block，TCB）</p>
<p>  2.设置线程的堆栈、寄存器</p>
<p>  3.设置线程的调度属性</p>
<p>  4.加入到进程的线程组中，这些线程共享进程的部分资源</p>
<p>这些创建出来的线程不创建地址空间，而是<strong>共享进程的地址空间和其他资源</strong>（文件描述符，信号处理器等），其创建的开销远小于进程，所以我们说Linux下线程可以看作是轻量级进程。</p>
<p>进程拥有自己独立的进程地址空间，进程具有独立性，而线程共享进程的地址空间，所有线程不具有独立性。线程除了共享进程地址空间，也拥有自己的私有成员：线程标识符、线程栈、线程寄存器</p>
<p><strong>线程栈和线程寄存器是线程的两个重要组成部分：</strong></p>
<ul>
<li>线程栈是一个特殊的内存区域，用于存储线程执行时的函数调用栈、局部变量、函数参数等数据。每个线程都有自己的线程栈，线程栈的大小在创建线程时可以指定。线程在执行过程中，会不断地向线程栈中压入和弹出函数调用的相关信息，从而实现程序的正常执行。</li>
<li>线程寄存器是CPU中的一组特殊寄存器，用于存储线程执行时的上下文信息，包括程序计数器、栈指针、通用寄存器等。线程在执行过程中，需要不断地保存和恢复这些寄存器的值，以便在线程切换时保持线程的执行状态。</li>
</ul>
<p>在Linux系统中，线程栈和线程寄存器是由内核进行管理和调度的。线程栈和线程寄存器的分配和初始化工作是由内核在创建线程时完成的，当线程被切换时，内核会将线程栈和线程寄存器中的内容保存下来，然后切换到其他线程的执行上下文。因此，线程栈和线程寄存器的正确使用和管理对于线程的正常运行至关重要。</p>
</li>
</ul>
<h4 id="1-2-Linux下线程的种类"><a href="#1-2-Linux下线程的种类" class="headerlink" title="1.2  Linux下线程的种类"></a>1.2  Linux下线程的种类</h4><ol>
<li>用户级线程（User-Level Thread，ULT）：这种线程是由用户空间的线程库（<strong>如 pthread库</strong>）实现的，线程的创建、调度、同步等都由线程库管理。内核对用户级线程是没有感知的，因此它们的调度和同步都是由用户空间的线程库完成的。由于用户级线程不需要进入内核空间，因此它们的切换比内核级线程快，但是它们无法利用多处理器。</li>
<li>内核级线程（Kernel-Level Thread，KLT）：这种线程由内核创建和管理，它们的调度和同步都是由内核完成的。内核级线程可以利用多处理器，但是它们的切换比用户级线程慢。Linux 中的内核级线程是使用轻量级进程实现的，每个进程都可以拥有多个轻量级进程，也就是说，一个进程可以拥有多个内核级线程。</li>
</ol>
<h2 id="2-pthread库的使用"><a href="#2-pthread库的使用" class="headerlink" title="2. pthread库的使用"></a>2. pthread库的使用</h2><p>pthread是官方提供的用户级的线程库，我们口中所指的线程大多就是指phread库为我们提供的用户级线程。</p>
<h4 id="2-1-头文件"><a href="#2-1-头文件" class="headerlink" title="2.1 头文件"></a>2.1 头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> <span class="comment">// 头文件 Linux系统默认带pthread库</span></span></span><br></pre></td></tr></table></figure>

<p>pthread不属于标准库，编译时需要带上 -lpthread</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cc -o test -lpthread</span><br></pre></td></tr></table></figure>

<h4 id="2-2-pthread-create"><a href="#2-2-pthread-create" class="headerlink" title="2.2 pthread_create"></a>2.2 pthread_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION</p>
<p>​	   The  pthread_create()  function  starts  a new thread in the calling process</p>
</blockquote>
<p>这个接口会在当前进程中创建出一个用户级线程</p>
<ul>
<li>第一个参数是线程的id</li>
<li>第二个参数是线程的属性，一般设置为nullptr</li>
<li>第三个参数是函数指针，这个函数的返回值是void*  ，参数为void* ，创建出来的线程会去执行这个函数</li>
<li>第四个参数是start_routine函数传给线程的参数</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>       On success, pthread_create() returns 0; on error, it returns an error number, and the contents of *thread are undefined.</p>
</blockquote>
<p>创建成功时，返回值为0，创建失败返回错误码。</p>
<h4 id="2-3-pthread-join"><a href="#2-3-pthread-join" class="headerlink" title="2.3 pthread_join"></a>2.3 pthread_join</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       The  pthread_join() function waits for the thread specified by thread to terminate.  If that thread has already terminated, then pthread_join() returns immediately.  </p>
<p>​	   The thread specified by thread must be joinable.</p>
</blockquote>
<p>这个接口会一直阻塞等待目标线程执行完毕后回收资源，如果线程已经被回收，会直接返回。</p>
<p>The thread specified by thread must be joinable. 意思是这个线程必须是joinable属性（创建线程时不指定属性的话默认是joinable）或者没有被显式的剥离（调用pthread_detach)。</p>
<p>由于线程占用的资源不会在线程执行完时自己释放，所以需要其他线程执行pthread_join（或者同时调用pthread_detach和pthread_exit)来释放资源，否则就会导致资源的泄露。</p>
<ul>
<li>第一个参数是等待的线程id</li>
<li>第二个参数可以接收等待的线程执行完毕后的返回值</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>       On success, pthread_join() returns 0; on error, it returns an error number.</p>
</blockquote>
<p>等待成功返回0，否则返回错误码</p>
<p>以下是一个简单的线程创建和等待回收的示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;run&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;t,nullptr,run,nullptr) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;pthread_create error\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞等待线程回收</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_join(t,nullptr) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;pthread_join success\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM-20-8-centos ]$ g++ test.cc -o test -lpthread -std=c++11</span><br><span class="line">[wyj@VM-20-8-centos ]$ ./test</span><br><span class="line">run</span><br><span class="line">pthread_join success</span><br></pre></td></tr></table></figure>

<h4 id="2-3-pthread-exit"><a href="#2-3-pthread-exit" class="headerlink" title="2.3 pthread_exit"></a>2.3 pthread_exit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       The  pthread_exit()  function  terminates  the calling thread and returns a value via retval that (if the thread is joinable) is<br>       available to another thread in the same process that calls pthread_join</p>
</blockquote>
<p>这个接口可以终止运行的线程，进程中其他没有被剥离（调用pthread_detach)的线程可以通过pthread_join接收这个被终止线程的返回值</p>
<ul>
<li>参数retval的值可以被其他线程通过pthread_join获取</li>
</ul>
<p>Linux下线程结束执行有以下几种情况:</p>
<ul>
<li>线程将指定函数体中的代码执行完后自行结束；</li>
<li>线程执行过程中，被同一进程中的其它线程（包括主线程）强制终止；</li>
<li>线程执行过程中，遇到 pthread_exit() 函数结束执行。</li>
</ul>
<p>下面给出几个简单的使用示例：</p>
<p><strong>通过pthread_exit退出线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_exit(<span class="string">&quot;pthread_exit&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line">    <span class="comment">// 阻塞等待线程回收</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(t, &amp;ret) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;pthread_join success\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span>*)ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ ./test</span><br><span class="line">pthread_join success</span><br><span class="line">pthread_exit</span><br></pre></td></tr></table></figure>

<p>由结果可知，线程调用pthread_exit后提前退出，没有执行后面的printf(“run\n”)，主线程通过pthread_join获得退出值</p>
<p><strong>强制退出线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM-20-8-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM-20-8-centos]$ ./test</span><br><span class="line">main thread exit</span><br></pre></td></tr></table></figure>

<p>由执行结果可知，创建出来的线程并没有执行run函数，这是因为本次运行，cpu的调度使得主线程先执行，而且主线程并没有调用pthread_join去阻塞等待子线程，当主线程执行return 0的时候会调用系统接口exit(), exit()会终止进程内的所有线程，所以子线程没有执行run函数就被强制退出了。</p>
<p>如果我们用pthread_exit提前退出主线程，不执行return 0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ ./test</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>由结果可知，主线程提前退出，没有执行return 0，子线程执行了run函数。pthread_exit退出当前线程，不会影响其他线程。</p>
<p><strong>此外，pthread_exit() 可以自动调用线程清理程序（本质是一个由 pthread_cleanup_push() 指定的自定义函数），return 则不具备这个能力。总之在实际场景中，如果想终止某个子线程执行，强烈建议大家使用 pthread_exit() 函数。</strong></p>
<h4 id="2-4-pthread-detach"><a href="#2-4-pthread-detach" class="headerlink" title="2.4 pthread_detach"></a>2.4 pthread_detach</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       The  pthread_detach()  function  marks  the  thread  identified  by  thread as detached.  When a detached thread terminates, its<br>       resources are automatically released back to the system without the need for another thread to join with the terminated thread.</p>
</blockquote>
<p>这个接口会将线程的状态设置为detached，当这个线程执行结束时，资源会被操作系统自动回收，不需要使用者手动调用pthread_join来回收。</p>
<ul>
<li>参数为线程的id</li>
</ul>
<p>我们知道，如果一个线程执行结束但还没有被join时，他的状态类似与进程中的僵尸进程（Zombie Process），需要创建线程的人手动调用pthread_join阻塞回收资源。</p>
<p>但有时我们并不想阻塞等待，导致效率降低，同时为了避免资源泄露，就可以使用pthread_detach，让操作系统替我们管理线程。</p>
<p>通常，在剥离子线程时，我们会让主线程保持在后台运行（常驻内存的程序），从而避免主线程退出，操作系统就自动回收被剥离的子线程，从而避免子线程还未执行完就退出的问题。</p>
<h4 id="2-5-gettid"><a href="#2-5-gettid" class="headerlink" title="2.5 gettid"></a>2.5 gettid</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t gettid(void);</span><br></pre></td></tr></table></figure>

<p>头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       gettid()  returns the caller’s thread ID (TID).  In a single-threaded process, the thread ID is equal to the process ID (PID, as<br>       returned by getpid().  In a multithreaded process, all threads have the same PID, but each one has a unique TID.</p>
</blockquote>
<p>gettid可以获取当前线程的线程tid，当进程内只有一个线程的时候，线程的tid等于进程的pid</p>
<p><strong>gettid是系统接口，需要通过syscall来调用</strong></p>
<h4 id="2-6-syscall"><a href="#2-6-syscall" class="headerlink" title="2.6 syscall"></a>2.6 syscall</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall</span><span class="params">(<span class="type">int</span> number, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span>   <span class="comment">/* For SYS_xxx definitions */</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>syscall()  is  a  small library function that invokes the system call whose assembly language interface has the specified number with the specified arguments.  Employing syscall() is useful, for example, when invoking a system call that has no wrapper function in the C library.</p>
<p>syscall() saves CPU registers before making the system call, restores the registers upon return from the system call, and stores any error code returned by the system call in errno if an error occurs.</p>
</blockquote>
<p>sycall()是一个小型库函数，它调用系统调用，其汇编语言接口具有指定编号和指定参数。例如，当调用C库中没有包装器函数的系统调用时，使用sycall()是有用的。</p>
<p>syscall()在进行系统调用之前保存CPU寄存器，在系统调用返回时恢复寄存器，并存储error中的错误码</p>
<p>以下是一个简单示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> tid;</span><br><span class="line"></span><br><span class="line">    tid = syscall(SYS_gettid);</span><br><span class="line">    tid = syscall(SYS_tgkill, getpid(), tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-线程互斥"><a href="#3-线程互斥" class="headerlink" title="3.线程互斥"></a>3.线程互斥</h2><h4 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h4><p>线程互斥是指在多个线程中，对同一临界资源的访问进行限制，保证同一时间只有一个线程能够访问该资源，以避免多个线程同时修改同一个资源而导致的数据不一致问题。</p>
<h4 id="3-2-临界资源"><a href="#3-2-临界资源" class="headerlink" title="3.2 临界资源"></a>3.2 临界资源</h4><p>临界资源是指共享的一段代码、一组数据或一块内存区域等，他们能被多个线程访问、修改，所以需要通过互斥访问来保证数据一致性的资源。比如，在一个多线程程序中，多个线程可能同时访问同一份数据结构，这时就需要使用临界资源的互斥访问来保证数据的正确性。</p>
<h4 id="3-3-锁"><a href="#3-3-锁" class="headerlink" title="3.3 锁"></a>3.3 锁</h4><p><strong>锁是一种解决多线程访问临界资源的冲突一种技术。</strong>锁的实现依赖于操作系统的调度和底层硬件的原子性操作。</p>
<h4 id="3-4-pthread-mutex"><a href="#3-4-pthread-mutex" class="headerlink" title="3.4 pthread_mutex"></a>3.4 pthread_mutex</h4><p>pthread_mutex是pthread库中实现的互斥锁，他的实现依赖于futex（fast userspace mutex）系统调用，它是一个基于用户空间和内核空间的协同机制，主要作用是将用户空间的线程挂起等待某个事件发生，并在事件发生时唤醒他们。futex底层实现中涉及到CPU提供的原子操作.</p>
<p>当一个线程想要加锁时，它会首先尝试在用户空间中使用原子操作（如CAS）来获取锁，如果获取成功，则直接返回；否则，线程会调用futex_wait函数挂起自己，并在内核中等待锁的释放。当锁被持有线程释放时，它会调用futex_wake函数唤醒等待的线程，使它们重新竞争锁。在这个过程中，操作系统内核会对锁进行一些状态的维护，例如是否有线程正在等待锁、锁的拥有者等等。</p>
<p>以下是X86架构CPU加锁过程汇编指令的简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock:</span><br><span class="line">    mov eax, 1   ; 将eax寄存器设置为1</span><br><span class="line">    xchg eax, [lock] ; 将eax寄存器中的值与lock变量中的值进行交换，lock变量中的值变为1</span><br><span class="line">    test eax, eax   ; 测试eax寄存器的值是否为0，为0则代表有锁资源</span><br><span class="line">    jnz lock    ; 如果eax寄存器的值不为0，跳转到lock标签处，继续尝试获取锁</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>lock初始化值为0,0代表有锁资源，1代表无锁资源</li>
<li>在单处理机中，一次只有一个线程能上处理机执行xchg指令，是原子性操作</li>
<li>实际的锁实现会更加复杂，涉及到缓存一致性、总线锁定等底层细节。</li>
</ul>
<p>以下是pthread库提供的关于锁操作的接口：</p>
<p><strong>锁变量：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> </span><br></pre></td></tr></table></figure>

<p><strong>初始化锁：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span><br><span class="line">       				   const pthread_mutexattr_t *restrict attr)</span><br><span class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>pthread库提供了两种初始化锁的方式：</p>
<ul>
<li>通过init接口，第二个参数可以设置锁的属性</li>
<li>通过宏 PTHREAD_MUTEX_INITIALIZER只能创建用于静态内存的锁，即在定义时直接声明的变量</li>
</ul>
<p><strong>加锁：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread库提供了两种加锁方式：</p>
<ul>
<li>lock是阻塞式加锁</li>
<li>unlock是非阻塞式加锁</li>
</ul>
<p><strong>解锁：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure>

<p><strong>释放锁：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>以下是不加锁情况下多线程访问临界资源的简单实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">10000</span>; <span class="comment">// 临界区资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">run</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt;<span class="string">&quot;tid：&quot;</span>&lt;&lt;<span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; --count &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, run, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，创建了3个线程去并发执行run函数，count是临界区资源，三个线程都可以访问修改count。</p>
<p>执行结果：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/1.png"></p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/1.1.png"></p>
<p>出现了各种输出错误和数据不一致，这是多线程访问临界资源导致的冲突情况。</p>
<p>以下是加锁以后的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1000</span>; <span class="comment">// 临界区资源</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">run</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">200</span>);</span><br><span class="line">            std::cout &lt;&lt;<span class="string">&quot;tid：&quot;</span>&lt;&lt;<span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; --count &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pthread_mutex_init(&amp;mutex,nullptr);</span></span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, run, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/2.png"></p>
<p>通过加锁解决了多线程访问临界资源冲突的问题。但是通过tid可以看出，整个进程生命周期里，<strong>几乎只有单个线程在执行任务</strong>，并不是我们预期设想的多个线程并发执行任务。</p>
<p>产生这种现象的原因：该线程执行任务的消耗小于CPU切换到其他线程的消耗，所以CPU调度机制会保持该线程运行下去，不会切换线程。这样就会导致其他线程创建出来却没有执行任务，反而浪费了系统的资源，为了解决这个问题，我们引入了<strong>线程同步</strong>。</p>
<h2 id="4-线程同步"><a href="#4-线程同步" class="headerlink" title="4. 线程同步"></a>4. 线程同步</h2><p>当我们对多线程互斥访问同一份资源不作限制时，完全由CPU去进行调度，就有可能会出现上面的线程饥饿现象，导致资源的浪费，因此我们引入了线程同步的概念，在保证线程访问安全的前提下，通过条件变量等机制去控制线程，使得多个线程能够按照一定的顺序、时间和方式执行。</p>
<h4 id="4-1-条件变量"><a href="#4-1-条件变量" class="headerlink" title="4.1 条件变量"></a>4.1 条件变量</h4><p>以下是pthread库提供的条件变量接口：</p>
<p><strong>条件变量：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化：</strong></p>
<p>类似于锁，pthread库提供了两种初始化条件变量方式：</p>
<ul>
<li>init接口，第二个参数可以设置条件变量属性</li>
<li>通过宏 PTHREAD_COND_INITIALIZER只能创建用于静态内存的锁，即在定义时直接声明的变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;              		  </span><br></pre></td></tr></table></figure>

<p><strong>等待条件变量信号：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_timedwait(pthread_cond_t *restrict cond,</span><br><span class="line">              pthread_mutex_t *restrict mutex,</span><br><span class="line">              const struct timespec *restrict abstime);</span><br><span class="line">int pthread_cond_wait(pthread_cond_t *restrict cond,</span><br><span class="line">              pthread_mutex_t *restrict mutex);</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数为条件变量，第二个参数为锁，目的是<strong>保证条件变量读写的原子性</strong></li>
<li>timedwait接口的多出的第三个参数可以设置等待的时间</li>
</ul>
<p><strong>!!! 注意，pthread库在wait和timewait内部做了类似下面的特殊处理：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">   pthread_mutex_unlock(mutex);</span><br><span class="line">    <span class="comment">// 阻塞等待条件变量信号</span></span><br><span class="line">   	 ...</span><br><span class="line">    <span class="comment">// 收到条件变量信号，如果有锁资源，加锁，没有锁资源，阻塞等待加锁</span></span><br><span class="line">   pthread_mutex_lock(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行条件变量信号等待时，会先进行解锁，阻塞等待条件变量信号，直到收到信号才会进行加锁。<strong>这样处理的目的是防止线程阻塞时占用锁资源，使得其他线程没法及时获得锁资源。</strong></p>
<p>这种特殊处理会导致使用条件变量时出现下面的情况：</p>
<p>收到条件变量信号的某个线程加锁后开始执行任务，其他线程的状态为阻塞等待条件变量信号或者阻塞等待锁资源，但假如拿到锁的线程退出后没有释放锁，就会导致其他线程一只阻塞等待阻塞等待加锁。</p>
<p><strong>为了避免这种情况的发生，需要程序员在程执行完后手动释放锁资源。</strong></p>
<p><strong>发送条件变量信号：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个接口会向所有阻塞在cond条件变量下的线程发送信号</li>
<li>第二个接口会向至少一个阻塞在cond条件变量下的线程发送信号</li>
</ul>
<h4 id="4-2-生产消费者模型–阻塞队列"><a href="#4-2-生产消费者模型–阻塞队列" class="headerlink" title="4.2 生产消费者模型–阻塞队列"></a>4.2 生产消费者模型–阻塞队列</h4><p>生产消费者是线程同步中常用的一个模型，它不仅能保证各种操作的原子性，还能实现访问控制。</p>
<p>生产消费者模型结构：</p>
<ul>
<li>任务队列：存放待执行任务的队列，</li>
<li>生产者：主线程向任务队列中添加任务并通知子线程</li>
<li>消费者：子线程从任务队列中取出任务并通知主线程</li>
</ul>
<p>通过锁来保证生产者添加任务和消费者取出任务操作的原子性，通过条件变量来控制线程。</p>
<p>下面是生产消费者模型的一个简单示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span>&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Task*&gt; queue_;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> *mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> *cond;</span><br><span class="line">    <span class="type">int</span> MaxNum;</span><br><span class="line">public:</span><br><span class="line">    TaskQueue(<span class="type">int</span> n)</span><br><span class="line">    :MaxNum(n)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(mutex,nullptr);</span><br><span class="line">        pthread_cond_init(cond,nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(Task *t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mutex);</span><br><span class="line">        <span class="keyword">if</span>(queue_.size()&gt;= MaxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(cond,mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        queue_.push(t);</span><br><span class="line">        pthread_cond_signal(cond);</span><br><span class="line">        pthread_mutex_unlock(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    Task* <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mutex);</span><br><span class="line">        <span class="keyword">if</span>(queue_.size()== <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(cond,mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        Task *t = queue_.front();</span><br><span class="line">        queue_.pop();</span><br><span class="line">        pthread_cond_signal(cond);</span><br><span class="line">        pthread_mutex_unlock(mutex);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5.线程池"></a>5.线程池</h2><p>线程池是通过<strong>池化技术</strong>实现的一种管理线程的技术栈，通过线程池技术，我们可以将线程的创建和任务的执行解耦开来，从而实现<strong>降低资源消耗</strong>、<strong>提高响应速度</strong> 、<strong>方便线程管理</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Threadpool</span>&#123;</span></span><br><span class="line">private:</span><br><span class="line">    Threadpool(<span class="type">int</span> threadNum)</span><br><span class="line">    :threadNum_(threadNum)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    Threadpool(<span class="type">const</span> Threadpool &amp;)=delete;</span><br><span class="line">    Threadpool &amp; operator =(<span class="type">const</span> Threadpool &amp;)=delete;</span><br><span class="line">    ~Threadpool();</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 获得线程池单例</span></span><br><span class="line">    <span class="type">static</span> Threadpool* <span class="title function_">GetInstance</span><span class="params">(<span class="type">int</span> threadNum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Double Check Lock</span></span><br><span class="line">        <span class="keyword">if</span>(instance == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;Mutex);</span><br><span class="line">            <span class="keyword">if</span>(instance ==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = new Threadpool(threadNum);</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;Mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务到任务队列</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">addTask</span><span class="params">(<span class="type">void</span>(*)(<span class="type">void</span>*),<span class="type">void</span> *args)</span>;</span><br><span class="line">    <span class="comment">// 添加空任务到任务队列</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">joinAll</span><span class="params">()</span>;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* <span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Task</span>&#123;</span></span><br><span class="line">        Task(<span class="type">void</span> (*func)(<span class="type">void</span>*),<span class="type">void</span> *args)</span><br><span class="line">        :args_(args)</span><br><span class="line">        ,func_(func)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *args_;<span class="comment">// 参数</span></span><br><span class="line">        <span class="type">void</span> (*func_)(<span class="type">void</span> *); <span class="comment">// 任务函数指针</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> Threadpool * instance;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Task*&gt; Taskqueue;<span class="comment">// 任务队列</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> queueMutex;<span class="comment">// 锁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> Mutex; <span class="comment">// 单例锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> queueCond;<span class="comment">// 条件变量</span></span><br><span class="line">    <span class="type">pthread_t</span> * threads; </span><br><span class="line">    <span class="type">int</span> threadNum_;<span class="comment">// 线程数量</span></span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line">Threadpool * Threadpool::instance =nullptr;</span><br><span class="line"><span class="type">pthread_mutex_t</span> Threadpool::Mutex;</span><br><span class="line"></span><br><span class="line">Threadpool::~Threadpool()</span><br><span class="line">&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    pthread_cond_broadcast(&amp;queueCond);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum_;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(threads[i],nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">    delete [] threads;</span><br><span class="line">    pthread_mutex_destroy(&amp;queueMutex);</span><br><span class="line">    pthread_cond_destroy(&amp;queueCond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">Threadpool::run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;instance-&gt;queueMutex);</span><br><span class="line">        <span class="keyword">while</span>(instance-&gt;Taskqueue.empty() &amp;&amp; !instance-&gt;stop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待线程被唤醒</span></span><br><span class="line">            pthread_cond_wait(&amp;instance-&gt;queueCond,&amp;instance-&gt;queueMutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(instance-&gt;stop)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;instance-&gt;queueMutex);</span><br><span class="line">            pthread_exit(nullptr);</span><br><span class="line">        &#125;</span><br><span class="line">        Task * task = instance-&gt;Taskqueue.front();</span><br><span class="line">        instance-&gt;Taskqueue.pop();</span><br><span class="line">        pthread_mutex_unlock(&amp;instance-&gt;queueMutex);</span><br><span class="line">        <span class="keyword">if</span>(task)</span><br><span class="line">        &#123;</span><br><span class="line">            task-&gt;func_(task-&gt;args_);</span><br><span class="line">            delete task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Threadpool::addTask</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>*),<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    Task *task= new Task(func,args);</span><br><span class="line">    pthread_mutex_lock(&amp;queueMutex);</span><br><span class="line">    Taskqueue.push(task);</span><br><span class="line">    <span class="comment">// 通知消费者消费</span></span><br><span class="line">    pthread_cond_signal(&amp;queueCond);</span><br><span class="line">    pthread_mutex_unlock(&amp;queueMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队列添加空任务</span></span><br><span class="line"><span class="type">void</span> Threadpool:: joinAll()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum_;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        addTask(nullptr,nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Threadpool::Threadpool(<span class="type">int</span> threadNum)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;threadNum_ = threadNum;</span><br><span class="line">    pthread_mutex_init(&amp;queueMutex,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;queueCond,<span class="literal">NULL</span>);</span><br><span class="line">    threads = new <span class="type">pthread_t</span>[threadNum];</span><br><span class="line">    stop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;threads[i],<span class="literal">NULL</span>,run,this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/04/26/%E7%BA%BF%E7%A8%8B/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/04/29/%E8%BF%9B%E7%A8%8B/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Linux进程
          
        </div>
      </a>
    
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> Yun Jia
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer.svg" alt="嘉禾望岗"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat%20(2).jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->

<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=2027529783&auto=1&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>