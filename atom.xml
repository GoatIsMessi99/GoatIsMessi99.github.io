<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>嘉禾望岗</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-28T14:43:41.602Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yun Jia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux下多线程编程及pthread库的使用</title>
    <link href="http://example.com/2023/04/26/linux/"/>
    <id>http://example.com/2023/04/26/linux/</id>
    <published>2023-04-25T16:00:00.000Z</published>
    <updated>2023-04-28T14:43:41.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Linux下的线程"><a href="#1-Linux下的线程" class="headerlink" title="1. Linux下的线程"></a>1. Linux下的线程</h2><h4 id="1-1-Linux下线程与进程的关系"><a href="#1-1-Linux下线程与进程的关系" class="headerlink" title="1.1 Linux下线程与进程的关系"></a>1.1 Linux下线程与进程的关系</h4><ul><li><p><strong>进程是操作系统分配资源的基本单位</strong></p></li><li><p><strong>线程是操作系统任务调度的基本单位</strong></p></li><li><p><strong>Linux内核中的线程可以看作是轻量级进程</strong></p><p>我们知道，Linux内核在创建<strong>进程</strong>时：</p><ol><li>创建并初始化<strong>进程控制块 PCB（Process Control Block）</strong>：它记录了进程的状态、标识符、优先级等。</li><li>为进程分配独立的虚拟进程地址空间，将程序、数据、库文件载入虚拟地址空间中。</li><li>复制父进程的内存空间：因为Linux采取了<strong>写时拷贝COW（Copy-On-Write）</strong>的技术，该进程的内存页表是父进程内存页表的一份拷贝，只有子进程需要修改其中某个内存页时，子进程的内存页表才会重新建立内存页表到物理空间的映射</li><li>复制父进程的文件描述符表</li><li>复制父进程的环境变量和命令行参数</li><li>复制父进程的信号处理器</li></ol><p>而Linux内核在创建<strong>线程</strong>时：</p><p>  1.初始化线程控制块（Thread Control Block，TCB）</p><p>  2.设置线程的堆栈</p><p>  3.设置线程的调度属性</p><p>  4.加入到进程的线程组中，这些线程共享进程的部分资源</p><p>这些创建出来的线程<strong>共享进程的地址空间和其他资源</strong>（文件描述符，信号处理器等），其创建的开销远小于进程，所以我们说Linux下线程可以看作是轻量级进程。</p></li></ul><h4 id="1-2-Linux下线程的种类"><a href="#1-2-Linux下线程的种类" class="headerlink" title="1.2  Linux下线程的种类"></a>1.2  Linux下线程的种类</h4><ol><li>用户级线程（User-Level Thread，ULT）：这种线程是由用户空间的线程库（<strong>如 pthread库</strong>）实现的，线程的创建、调度、同步等都由线程库管理。内核对用户级线程是没有感知的，因此它们的调度和同步都是由用户空间的线程库完成的。由于用户级线程不需要进入内核空间，因此它们的切换比内核级线程快，但是它们无法利用多处理器。</li><li>内核级线程（Kernel-Level Thread，KLT）：这种线程由内核创建和管理，它们的调度和同步都是由内核完成的。内核级线程可以利用多处理器，但是它们的切换比用户级线程慢。Linux 中的内核级线程是使用轻量级进程实现的，每个进程都可以拥有多个轻量级进程，也就是说，一个进程可以拥有多个内核级线程。</li></ol><h2 id="2-pthread库的使用"><a href="#2-pthread库的使用" class="headerlink" title="2. pthread库的使用"></a>2. pthread库的使用</h2><p>pthread是官方提供的用户级的线程库，我们口中所指的线程大多就是指phread库为我们提供的用户级线程。</p><h4 id="2-1-头文件"><a href="#2-1-头文件" class="headerlink" title="2.1 头文件"></a>2.1 头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> <span class="comment">// 头文件 Linux系统默认带pthread库</span></span></span><br></pre></td></tr></table></figure><p>pthread不属于标准库，编译时需要带上 -lpthread</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cc -o test -lpthread</span><br></pre></td></tr></table></figure><h4 id="2-2-pthread-create"><a href="#2-2-pthread-create" class="headerlink" title="2.2 pthread_create"></a>2.2 pthread_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>DESCRIPTION</p><p>​   The  pthread_create()  function  starts  a new thread in the calling process</p></blockquote><p>这个接口会在当前进程中创建出一个用户级线程</p><ul><li>第一个参数是线程的id</li><li>第二个参数是线程的属性，一般设置为nullptr</li><li>第三个参数是函数指针，这个函数的返回值是void*  ，参数为void* ，创建出来的线程会去执行这个函数</li><li>第四个参数是start_routine函数传给线程的参数</li></ul><blockquote><p>RETURN VALUE<br>       On success, pthread_create() returns 0; on error, it returns an error number, and the contents of *thread are undefined.</p></blockquote><p>创建成功时，返回值为0，创建失败返回错误码。</p><h4 id="2-3-pthread-join"><a href="#2-3-pthread-join" class="headerlink" title="2.3 pthread_join"></a>2.3 pthread_join</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>DESCRIPTION<br>       The  pthread_join() function waits for the thread specified by thread to terminate.  If that thread has already terminated, then pthread_join() returns immediately.  </p><p>​   The thread specified by thread must be joinable.</p></blockquote><p>这个接口会一直阻塞等待目标线程执行完毕后回收资源，如果线程已经被回收，会直接返回。</p><p>The thread specified by thread must be joinable. 意思是这个线程必须是joinable属性（创建线程时不指定属性的话默认是joinable）或者没有被显式的剥离（调用pthread_detach)。</p><p>由于线程占用的资源不会在线程执行完时自己释放，所以需要其他线程执行pthread_join（或者同时调用pthread_detach和pthread_exit)来释放资源，否则就会导致资源的泄露。</p><ul><li>第一个参数是等待的线程id</li><li>第二个参数可以接收等待的线程执行完毕后的返回值</li></ul><blockquote><p>RETURN VALUE<br>       On success, pthread_join() returns 0; on error, it returns an error number.</p></blockquote><p>等待成功返回0，否则返回错误码</p><p>以下是一个简单的线程创建和等待回收的示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;run&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;t,nullptr,run,nullptr) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;pthread_create error\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞等待线程回收</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_join(t,nullptr) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;pthread_join success\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM-20-8-centos ]$ g++ test.cc -o test -lpthread -std=c++11</span><br><span class="line">[wyj@VM-20-8-centos ]$ ./test</span><br><span class="line">run</span><br><span class="line">pthread_join success</span><br></pre></td></tr></table></figure><h4 id="2-3-pthread-exit"><a href="#2-3-pthread-exit" class="headerlink" title="2.3 pthread_exit"></a>2.3 pthread_exit</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>DESCRIPTION<br>       The  pthread_exit()  function  terminates  the calling thread and returns a value via retval that (if the thread is joinable) is<br>       available to another thread in the same process that calls pthread_join</p></blockquote><p>这个接口可以终止运行的线程，进程中其他没有被剥离（调用pthread_detach)的线程可以通过pthread_join接收这个被终止线程的返回值</p><ul><li>参数retval的值可以被其他线程通过pthread_join获取</li></ul><p>Linux下线程结束执行有以下几种情况:</p><ul><li>线程将指定函数体中的代码执行完后自行结束；</li><li>线程执行过程中，被同一进程中的其它线程（包括主线程）强制终止；</li><li>线程执行过程中，遇到 pthread_exit() 函数结束执行。</li></ul><p>下面给出几个简单的使用示例：</p><p><strong>通过pthread_exit退出线程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_exit(<span class="string">&quot;pthread_exit&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line">    <span class="comment">// 阻塞等待线程回收</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(t, &amp;ret) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;pthread_join success\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span>*)ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ ./test</span><br><span class="line">pthread_join success</span><br><span class="line">pthread_exit</span><br></pre></td></tr></table></figure><p>由结果可知，线程调用pthread_exit后提前退出，没有执行后面的printf(“run\n”)，主线程通过pthread_join获得退出值</p><p><strong>强制退出线程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM-20-8-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM-20-8-centos]$ ./test</span><br><span class="line">main thread exit</span><br></pre></td></tr></table></figure><p>由执行结果可知，创建出来的线程并没有执行run函数，这是因为本次运行，cpu的调度使得主线程先执行，而且主线程并没有调用pthread_join去阻塞等待子线程，当主线程执行return 0的时候会调用系统接口exit(), exit()会终止进程内的所有线程，所以子线程没有执行run函数就被强制退出了。</p><p>如果我们用pthread_exit提前退出主线程，不执行return 0：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ ./test</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>由结果可知，主线程提前退出，没有执行return 0，子线程执行了run函数。pthread_exit退出当前线程，不会影响其他线程。</p><p><strong>此外，pthread_exit() 可以自动调用线程清理程序（本质是一个由 pthread_cleanup_push() 指定的自定义函数），return 则不具备这个能力。总之在实际场景中，如果想终止某个子线程执行，强烈建议大家使用 pthread_exit() 函数。</strong></p><h4 id="2-4-pthread-detach"><a href="#2-4-pthread-detach" class="headerlink" title="2.4 pthread_detach"></a>2.4 pthread_detach</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>DESCRIPTION<br>       The  pthread_detach()  function  marks  the  thread  identified  by  thread as detached.  When a detached thread terminates, its<br>       resources are automatically released back to the system without the need for another thread to join with the terminated thread.</p></blockquote><p>这个接口会将线程的状态设置为detached，当这个线程执行结束时，资源会被操作系统自动回收，不需要使用者手动调用pthread_join来回收。</p><ul><li>参数为线程的id</li></ul><p>我们知道，如果一个线程执行结束但还没有被join时，他的状态类似与进程中的僵尸进程（Zombie Process），需要创建线程的人手动调用pthread_join阻塞回收资源。</p><p>但有时我们并不想阻塞等待，导致效率降低，同时为了避免资源泄露，就可以使用pthread_detach，让操作系统替我们管理线程。</p><p>通常，在剥离子线程时，我们会让主线程保持在后台运行（常驻内存的程序），从而避免主线程退出，操作系统就自动回收被剥离的子线程，从而避免子线程还未执行完就退出的问题。</p><h4 id="2-5-gettid"><a href="#2-5-gettid" class="headerlink" title="2.5 gettid"></a>2.5 gettid</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t gettid(void);</span><br></pre></td></tr></table></figure><p>头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>DESCRIPTION<br>       gettid()  returns the caller’s thread ID (TID).  In a single-threaded process, the thread ID is equal to the process ID (PID, as<br>       returned by getpid().  In a multithreaded process, all threads have the same PID, but each one has a unique TID.</p></blockquote><p>gettid可以获取当前线程的线程tid，当进程内只有一个线程的时候，线程的tid等于进程的pid</p><p><strong>gettid是系统接口，需要通过syscall来调用</strong></p><h4 id="2-6-syscall"><a href="#2-6-syscall" class="headerlink" title="2.6 syscall"></a>2.6 syscall</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall</span><span class="params">(<span class="type">int</span> number, ...)</span>;</span><br></pre></td></tr></table></figure><p>头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span>   <span class="comment">/* For SYS_xxx definitions */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>syscall()  is  a  small library function that invokes the system call whose assembly language interface has the specified number with the specified arguments.  Employing syscall() is useful, for example, when invoking a system call that has no wrapper function in the C library.</p><p>syscall() saves CPU registers before making the system call, restores the registers upon return from the system call, and stores any error code returned by the system call in errno if an error occurs.</p></blockquote><p>sycall()是一个小型库函数，它调用系统调用，其汇编语言接口具有指定编号和指定参数。例如，当调用C库中没有包装器函数的系统调用时，使用sycall()是有用的。</p><p>syscall()在进行系统调用之前保存CPU寄存器，在系统调用返回时恢复寄存器，并存储error中的错误码</p><p>以下是一个简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> tid;</span><br><span class="line"></span><br><span class="line">    tid = syscall(SYS_gettid);</span><br><span class="line">    tid = syscall(SYS_tgkill, getpid(), tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-线程互斥"><a href="#3-线程互斥" class="headerlink" title="3.线程互斥"></a>3.线程互斥</h2><h4 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h4><p>线程互斥是指在多个线程中，对同一临界资源的访问进行限制，保证同一时间只有一个线程能够访问该资源，以避免多个线程同时修改同一个资源而导致的数据不一致问题。</p><h4 id="3-2-临界资源"><a href="#3-2-临界资源" class="headerlink" title="3.2 临界资源"></a>3.2 临界资源</h4><p>临界资源是指共享的一段代码、一组数据或一块内存区域等，他们能被多个线程访问、修改，所以需要通过互斥访问来保证数据一致性的资源。比如，在一个多线程程序中，多个线程可能同时访问同一份数据结构，这时就需要使用临界资源的互斥访问来保证数据的正确性。</p><h4 id="3-3-锁"><a href="#3-3-锁" class="headerlink" title="3.3 锁"></a>3.3 锁</h4><p><strong>锁是一种解决多线程访问临界资源的冲突一种技术。</strong>锁的实现依赖于操作系统的调度和底层硬件的原子性操作。</p><h4 id="3-4-pthread-mutex"><a href="#3-4-pthread-mutex" class="headerlink" title="3.4 pthread_mutex"></a>3.4 pthread_mutex</h4><p>pthread_mutex是pthread库中实现的互斥锁，他的实现依赖于futex（fast userspace mutex）系统调用，它是一个基于用户空间和内核空间的协同机制，主要作用是将用户空间的线程挂起等待某个事件发生，并在事件发生时唤醒他们。futex底层实现中涉及到CPU提供的原子操作.</p><p>当一个线程想要加锁时，它会首先尝试在用户空间中使用原子操作（如CAS）来获取锁，如果获取成功，则直接返回；否则，线程会调用futex_wait函数挂起自己，并在内核中等待锁的释放。当锁被持有线程释放时，它会调用futex_wake函数唤醒等待的线程，使它们重新竞争锁。在这个过程中，操作系统内核会对锁进行一些状态的维护，例如是否有线程正在等待锁、锁的拥有者等等。</p><p>以下是X86架构CPU加锁过程汇编指令的简单示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock:</span><br><span class="line">    mov eax, 1   ; 将eax寄存器设置为1</span><br><span class="line">    xchg eax, [lock] ; 将eax寄存器中的值与lock变量中的值进行交换，lock变量中的值变为1</span><br><span class="line">    test eax, eax   ; 测试eax寄存器的值是否为0，为0则代表有锁资源</span><br><span class="line">    jnz lock    ; 如果eax寄存器的值不为0，跳转到lock标签处，继续尝试获取锁</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>lock初始化值为0,0代表有锁资源，1代表无锁资源</li><li>在单处理机中，一次只有一个线程能上处理机执行xchg指令，是原子性操作</li><li>实际的锁实现会更加复杂，涉及到缓存一致性、总线锁定等底层细节。</li></ul><p>以下是pthread库提供的关于锁操作的接口：</p><p><strong>锁变量：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> </span><br></pre></td></tr></table></figure><p><strong>初始化锁：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span><br><span class="line">          const pthread_mutexattr_t *restrict attr)</span><br><span class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>pthread库提供了两种初始化锁的方式：</p><ul><li>通过init接口，第二个参数可以设置锁的属性</li><li>通过宏 PTHREAD_MUTEX_INITIALIZER只能创建用于静态内存的锁，即在定义时直接声明的变量</li></ul><p><strong>加锁：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>pthread库提供了两种加锁方式：</p><ul><li>lock是阻塞式加锁</li><li>unlock是非阻塞式加锁</li></ul><p><strong>解锁：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure><p><strong>释放锁：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>以下是不加锁情况下多线程访问临界资源的简单实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">10000</span>; <span class="comment">// 临界区资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">run</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt;<span class="string">&quot;tid：&quot;</span>&lt;&lt;<span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; --count &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, run, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，创建了3个线程去并发执行run函数，count是临界区资源，三个线程都可以访问修改count。</p><p>执行结果：</p><p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/1.png"></p><p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/1.1.png"></p><p>出现了各种输出错误和数据不一致，这是多线程访问临界资源导致的冲突情况。</p><p>以下是加锁以后的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1000</span>; <span class="comment">// 临界区资源</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">run</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">200</span>);</span><br><span class="line">            std::cout &lt;&lt;<span class="string">&quot;tid：&quot;</span>&lt;&lt;<span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; --count &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pthread_mutex_init(&amp;mutex,nullptr);</span></span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, run, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/2.png"></p><p>通过加锁解决了多线程访问临界资源冲突的问题。但是通过tid可以看出，整个进程生命周期里，<strong>几乎只有单个线程在执行任务</strong>，并不是我们预期设想的多个线程并发执行任务。</p><p>产生这种现象的原因：该线程执行任务的消耗小于CPU切换到其他线程的消耗，所以CPU调度机制会保持该线程运行下去，不会切换线程。这样就会导致其他线程创建出来却没有执行任务，反而浪费了系统的资源，为了解决这个问题，我们引入了<strong>线程同步</strong>。</p><h2 id="4-线程同步"><a href="#4-线程同步" class="headerlink" title="4. 线程同步"></a>4. 线程同步</h2><p>当我们对多线程互斥访问同一份资源不作限制时，完全由CPU去进行调度，就有可能会出现上面的线程饥饿现象，导致资源的浪费，因此我们引入了线程同步的概念，在保证线程访问安全的前提下，通过条件变量等机制去控制线程，使得多个线程能够按照一定的顺序、时间和方式执行。</p><h4 id="4-1-条件变量"><a href="#4-1-条件变量" class="headerlink" title="4.1 条件变量"></a>4.1 条件变量</h4><p>以下是pthread库提供的条件变量接口：</p><p><strong>条件变量：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span></span><br></pre></td></tr></table></figure><p><strong>初始化：</strong></p><p>类似于锁，pthread库提供了两种初始化条件变量方式：</p><ul><li>init接口，第二个参数可以设置条件变量属性</li><li>通过宏 PTHREAD_COND_INITIALIZER只能创建用于静态内存的锁，即在定义时直接声明的变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;                </span><br></pre></td></tr></table></figure><p><strong>等待条件变量信号：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_timedwait(pthread_cond_t *restrict cond,</span><br><span class="line">              pthread_mutex_t *restrict mutex,</span><br><span class="line">              const struct timespec *restrict abstime);</span><br><span class="line">int pthread_cond_wait(pthread_cond_t *restrict cond,</span><br><span class="line">              pthread_mutex_t *restrict mutex);</span><br></pre></td></tr></table></figure><ul><li>第一个参数为条件变量，第二个参数为锁，目的是<strong>保证条件变量读写的原子性</strong></li><li>timedwait接口的多出的第三个参数可以设置等待的时间</li></ul><p><strong>!!! 注意，pthread库在wait和timewait内部做了类似下面的特殊处理：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">   pthread_mutex_unlock(mutex);</span><br><span class="line">    <span class="comment">// 阻塞等待条件变量信号</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 收到条件变量信号，如果有锁资源，加锁，没有锁资源，阻塞等待加锁</span></span><br><span class="line">   pthread_mutex_lock(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行条件变量信号等待时，会先进行解锁，阻塞等待条件变量信号，直到收到信号才会进行加锁。<strong>这样处理的目的是防止线程阻塞时占用锁资源，使得其他线程没法及时获得锁资源。</strong></p><p>这种特殊处理会导致使用条件变量时出现下面的情况：</p><p>收到条件变量信号的某个线程加锁后开始执行任务，其他线程的状态为阻塞等待条件变量信号或者阻塞等待锁资源，但假如拿到锁的线程退出后没有释放锁，就会导致其他线程一只阻塞等待阻塞等待加锁。</p><p><strong>为了避免这种情况的发生，需要程序员在程执行完后手动释放锁资源。</strong></p><p><strong>发送条件变量信号：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个接口会向所有阻塞在cond条件变量下的线程发送信号</li><li>第二个接口会向至少一个阻塞在cond条件变量下的线程发送信号</li></ul><h4 id="4-2-生产消费者模型–阻塞队列"><a href="#4-2-生产消费者模型–阻塞队列" class="headerlink" title="4.2 生产消费者模型–阻塞队列"></a>4.2 生产消费者模型–阻塞队列</h4><p>生产消费者是线程同步中常用的一个模型，它不仅能保证各种操作的原子性，还能实现访问控制。</p><p>生产消费者模型结构：</p><ul><li>任务队列：存放待执行任务的队列，</li><li>生产者：主线程向任务队列中添加任务并通知子线程</li><li>消费者：子线程从任务队列中取出任务并通知主线程</li></ul><p>通过锁来保证生产者添加任务和消费者取出任务操作的原子性，通过条件变量来控制线程。</p><p>下面是生产消费者模型的一个简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span>&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Task*&gt; queue_;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> *mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> *cond;</span><br><span class="line">    <span class="type">int</span> MaxNum;</span><br><span class="line">public:</span><br><span class="line">    TaskQueue(<span class="type">int</span> n)</span><br><span class="line">    :MaxNum(n)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(mutex,nullptr);</span><br><span class="line">        pthread_cond_init(cond,nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(Task *t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mutex);</span><br><span class="line">        <span class="keyword">if</span>(queue_.size()&gt;= MaxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(cond,mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        queue_.push(t);</span><br><span class="line">        pthread_cond_signal(cond);</span><br><span class="line">        pthread_mutex_unlock(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    Task* <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mutex);</span><br><span class="line">        <span class="keyword">if</span>(queue_.size()== <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(cond,mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        Task *t = queue_.front();</span><br><span class="line">        queue_.pop();</span><br><span class="line">        pthread_cond_signal(cond);</span><br><span class="line">        pthread_mutex_unlock(mutex);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5.线程池"></a>5.线程池</h2><p>线程池是通过<strong>池化技术</strong>实现的一种管理线程的技术栈，通过线程池技术，我们可以将线程的创建和任务的执行解耦开来，从而实现<strong>降低资源消耗</strong>、<strong>提高响应速度</strong> 、<strong>方便线程管理</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Threadpool</span>&#123;</span></span><br><span class="line">private:</span><br><span class="line">    Threadpool(<span class="type">int</span> threadNum)</span><br><span class="line">    :threadNum_(threadNum)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    Threadpool(<span class="type">const</span> Threadpool &amp;)=delete;</span><br><span class="line">    Threadpool &amp; operator =(<span class="type">const</span> Threadpool &amp;)=delete;</span><br><span class="line">    ~Threadpool();</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 获得线程池单例</span></span><br><span class="line">    <span class="type">static</span> Threadpool* <span class="title function_">GetInstance</span><span class="params">(<span class="type">int</span> threadNum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Double Check Lock</span></span><br><span class="line">        <span class="keyword">if</span>(instance == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;Mutex);</span><br><span class="line">            <span class="keyword">if</span>(instance ==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = new Threadpool(threadNum);</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;Mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务到任务队列</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">addTask</span><span class="params">(<span class="type">void</span>(*)(<span class="type">void</span>*),<span class="type">void</span> *args)</span>;</span><br><span class="line">    <span class="comment">// 添加空任务到任务队列</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">joinAll</span><span class="params">()</span>;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* <span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Task</span>&#123;</span></span><br><span class="line">        Task(<span class="type">void</span> (*func)(<span class="type">void</span>*),<span class="type">void</span> *args)</span><br><span class="line">        :args_(args)</span><br><span class="line">        ,func_(func)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *args_;<span class="comment">// 参数</span></span><br><span class="line">        <span class="type">void</span> (*func_)(<span class="type">void</span> *); <span class="comment">// 任务函数指针</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> Threadpool * instance;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Task*&gt; Taskqueue;<span class="comment">// 任务队列</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> queueMutex;<span class="comment">// 锁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> Mutex; <span class="comment">// 单例锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> queueCond;<span class="comment">// 条件变量</span></span><br><span class="line">    <span class="type">pthread_t</span> * threads; </span><br><span class="line">    <span class="type">int</span> threadNum_;<span class="comment">// 线程数量</span></span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line">Threadpool * Threadpool::instance =nullptr;</span><br><span class="line"><span class="type">pthread_mutex_t</span> Threadpool::Mutex;</span><br><span class="line"></span><br><span class="line">Threadpool::~Threadpool()</span><br><span class="line">&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    pthread_cond_broadcast(&amp;queueCond);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum_;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(threads[i],nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">    delete [] threads;</span><br><span class="line">    pthread_mutex_destroy(&amp;queueMutex);</span><br><span class="line">    pthread_cond_destroy(&amp;queueCond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">Threadpool::run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;instance-&gt;queueMutex);</span><br><span class="line">        <span class="keyword">while</span>(instance-&gt;Taskqueue.empty() &amp;&amp; !instance-&gt;stop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待线程被唤醒</span></span><br><span class="line">            pthread_cond_wait(&amp;instance-&gt;queueCond,&amp;instance-&gt;queueMutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(instance-&gt;stop)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;instance-&gt;queueMutex);</span><br><span class="line">            pthread_exit(nullptr);</span><br><span class="line">        &#125;</span><br><span class="line">        Task * task = instance-&gt;Taskqueue.front();</span><br><span class="line">        instance-&gt;Taskqueue.pop();</span><br><span class="line">        pthread_mutex_unlock(&amp;instance-&gt;queueMutex);</span><br><span class="line">        <span class="keyword">if</span>(task)</span><br><span class="line">        &#123;</span><br><span class="line">            task-&gt;func_(task-&gt;args_);</span><br><span class="line">            delete task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Threadpool::addTask</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>*),<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    Task *task= new Task(func,args);</span><br><span class="line">    pthread_mutex_lock(&amp;queueMutex);</span><br><span class="line">    Taskqueue.push(task);</span><br><span class="line">    <span class="comment">// 通知消费者消费</span></span><br><span class="line">    pthread_cond_signal(&amp;queueCond);</span><br><span class="line">    pthread_mutex_unlock(&amp;queueMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队列添加空任务</span></span><br><span class="line"><span class="type">void</span> Threadpool:: joinAll()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum_;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        addTask(nullptr,nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Threadpool::Threadpool(<span class="type">int</span> threadNum)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;threadNum_ = threadNum;</span><br><span class="line">    pthread_mutex_init(&amp;queueMutex,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;queueCond,<span class="literal">NULL</span>);</span><br><span class="line">    threads = new <span class="type">pthread_t</span>[threadNum];</span><br><span class="line">    stop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;threads[i],<span class="literal">NULL</span>,run,this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
  </entry>
  
</feed>
