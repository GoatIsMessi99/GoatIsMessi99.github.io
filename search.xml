<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++类型推导规则</title>
    <url>/2023/05/22/Modern%20Effective%20C++%20-%20%E6%A8%A1%E6%9D%BF%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-理解不同场景下的模板推导规则"><a href="#1-理解不同场景下的模板推导规则" class="headerlink" title="1. 理解不同场景下的模板推导规则"></a>1. 理解不同场景下的模板推导规则</h2><p>C++的模板推导规则，对于初学者来说，可能会觉得非常复杂、难以理解，因为在不同场景下，模板的推导规则是不同的。为了能让learner更好的理解C++模板推导，本文将针对以下三种场景，给出模板的推导规则，帮助大家理解。</p>
<ol>
<li>param既不是指针也不是引用</li>
<li>param是引用</li>
<li>param是万能引用</li>
</ol>
<h4 id="1-1-param既不是指针也不是引用"><a href="#1-1-param既不是指针也不是引用" class="headerlink" title="1.1 param既不是指针也不是引用"></a>1.1 param既不是指针也不是引用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印模板T的类型</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;T: &quot;</span>&lt;&lt;boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 打印参数param的类型</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;param: &quot;</span>&lt;&lt;boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分别用左值，右值，const，数组，volatile进行测试</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">   <span class="type">int</span> c[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="type">int</span> d = <span class="number">3</span>;</span><br><span class="line">   <span class="type">int</span> &amp;e = a;</span><br><span class="line">   <span class="built_in">func</span>(a);</span><br><span class="line">   <span class="built_in">func</span>(b);</span><br><span class="line">   <span class="built_in">func</span>(c);</span><br><span class="line">   <span class="built_in">func</span>(d);</span><br><span class="line">   <span class="built_in">func</span>(e);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>得出的结果如下：</p>
<p><img src="https://lemon-pi.oss-cn-beijing.aliyuncs.com/img/202309261812227.png"></p>
<p>通过观察结果，我们得到以下结论：</p>
<ul>
<li>变量的const 、volatile属性会去除</li>
<li>数组名会被推导成指针类型</li>
</ul>
<p>这种情况下，编译器推导类型时，会做一定的处理，有时会导致属性的丢失，如果有些场景下你需要保留变量的属性，那么就可以考虑下面的情况。</p>
<h4 id="1-2-param是指针或者左值引用"><a href="#1-2-param是指针或者左值引用" class="headerlink" title="1.2 param是指针或者左值引用"></a>1.2 param是指针或者左值引用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T &amp;param)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;T: &quot;</span>&lt;&lt;boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;param: &quot;</span>&lt;&lt;boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用相同的代码进行测试，得到如下结果：</p>
<p><img src="https://lemon-pi.oss-cn-beijing.aliyuncs.com/img/202309261814024.png"></p>
<p>通过对上述两种情况下模板推导规则对比，我们得到以下结论：</p>
<ul>
<li>param是左值引用或指针时，模板会保留const，volatile属性，param非引用时，会丢失属性</li>
<li>param是左值引用或指针时，数组类型可以被完全推导出来</li>
</ul>
<p>但是，仔细观察这两种模板推导规则，我们会发现，他们对于右值的处理并不一定能满足我们的需求：</p>
<ol>
<li>当param既不是引用也不是指针时，右值会被模板推导成左值类型，丢失了右值的属性</li>
<li>当param是引用或者指针时，我们无法传递右值参数</li>
</ol>
<p>C++通过下面的万能引用、引用折叠技术解决了模板推导对于右值的处理。</p>
<h4 id="1-3-param是万能引用"><a href="#1-3-param是万能引用" class="headerlink" title="1.3 param是万能引用"></a>1.3 param是万能引用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T &amp;&amp;param)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;T: &quot;</span>&lt;&lt;boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;param: &quot;</span>&lt;&lt;boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用相同的代码进行测试，得到如下结果：</p>
<p><img src="https://lemon-pi.oss-cn-beijing.aliyuncs.com/img/202309261842023.png"></p>
<p>通过模板推导的结果，我们发现了此时对于左值的推导结果与上述两种情况都不一样：<strong>左值被推导成了左值引用</strong></p>
<p><code>以int为例，T推导出来的类型为int &amp;，但是为什么最后的param类型却是左值引用，而不是int&amp; &amp;&amp;呢？答案是C++引入了折叠引用规则,经过引用折叠,int &amp; &amp;&amp;会被折叠成int &amp;</code></p>
<p>我们会惊奇的发现，传的指是什么类型，最终param就是什么类型，同时还能保持参数的const、volatile属性！</p>
<ul>
<li>左值会被推导成左值引用，经过引用折叠，最终param的类型为左值引用</li>
<li>右值会被推导成左值类型，所以param就是右值</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>在模板类型推导中，入参的引用修饰符会被忽略。（reference-ness is ignored）</li>
<li>推导万能引用参数时，左值入参会被特殊处理</li>
<li>推导传值参数时，const 和 volatile 入参会被当做非 const volatile 变量处理（因为对象在传递时已经被复制）</li>
<li>在模板类型推导中，数组或函数入参会退化为指针，除非模板中使用引用参数</li>
</ul>
<h2 id="2-理解auto与decltype"><a href="#2-理解auto与decltype" class="headerlink" title="2. 理解auto与decltype"></a>2. 理解auto与decltype</h2><h4 id="2-1-auto"><a href="#2-1-auto" class="headerlink" title="2.1 auto"></a>2.1 auto</h4><p>绝大部分情况下，auto与模板是等价的，二者推导类型的规则几乎是一致的，以下代码可表明auto与模板的等价性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;   <span class="comment">// 等价于以下模板推导</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_x</span><span class="params">(T param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; rx = x;	<span class="comment">// 等价于以下模板推导</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_rx</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;cx = x;	<span class="comment">// 等价于以下模板推导</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_cx</span><span class="params">(T &amp;&amp;param)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但是部分情况下，auto能比模板处理更多类型推导：</p>
<ul>
<li>用initializer_list初始化变量时，auto推导类型为initializer_list</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// Type: std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>而此时模板则需要显示实例化为initializer_list：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::initializer_list&lt;T&gt; initList)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>C++14中，auto可以推导函数的返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto createInterger() &#123;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-decltype"><a href="#2-1-decltype" class="headerlink" title="2.1 decltype"></a>2.1 decltype</h3><p>decltype可以<strong>根据变量名、表达式推导出准确的类型。</strong>与auto相比，decltype可以更直观、方便的精准的推导出变量的类型，而auto更多的用法是推导类型后初始化变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> &amp;b = a;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">decltype</span>(a) d; <span class="comment">// 非引用和非const变量可以声明而不初始化</span></span><br><span class="line">   <span class="keyword">decltype</span>(b) e = a;</span><br><span class="line">   <span class="keyword">decltype</span>(c) f = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>推导结果：</p>
<p><img src="https://lemon-pi.oss-cn-beijing.aliyuncs.com/img/202309262203371.png"></p>
<p>decltype根据变量的结果精确推导处理变量类型，会保留变量的引用修饰符，const、volatile属性。并且，如果推导结果不是引用或者const变量，可以只声明变量不需要初始化，auto则必须初始化。</p>
<p>在C++14中，提出了decltype(auto)的用法，看起来非常奇怪，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;class Container&gt;</span><br><span class="line">decltype(auto) func(Container &amp;container, int index) &#123;</span><br><span class="line">    return container[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会疑惑，auto本身就可以推导，为什么要加decltype?原因是容器的operator[]一般返回的是容器内元素的引用，<strong>如果是auto推导，auto会去除引用的修饰符</strong>，当加上decltype之后，auto就会按照decltype的推导规则去推导，返回值的类型就会保持引用的修饰符！</p>
]]></content>
      <categories>
        <category>Modern Effective C++</category>
      </categories>
  </entry>
  <entry>
    <title>Tcp/Udp协议及Linux下Socket编程</title>
    <url>/2023/05/12/Socket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h2><p>OSI是国际标准化组织（ISO）提出的网络体系结构模型，作为<strong>开放系统互连参考模型</strong>，是进行网络通信的基本框架。OS七层模型分别为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层，但是在实际网络通信框架中，一般只设有五层：应用层、传输层、网络层、数据链路层、物理层，将表示层和会话层的内容统一到应用层中。</p>
<p><strong>报文：</strong></p>
<p>报文 &#x3D; 报头 + 数据部分</p>
<p>通过将网络划分成不同层结构，实现任务的划分，每一层都有自己对应的处理任务和特有的属性。</p>
<p>不同层之间采用报文的方式来传递数据，报文由报头和数据部分组成，每一层都有自己的报头，其中报头就填充着每一层的属性字段。</p>
<p>向下交付时，每一层向下交付的报文都会成为下一层的数据部分，下一层再组装上自己的报头以后就继续向下交付。</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.5.png"></p>
<h2 id="2-传输层协议"><a href="#2-传输层协议" class="headerlink" title="2. 传输层协议"></a>2. 传输层协议</h2><p>在实际网络通信五层框架中，每一层都有对应的任务和执行任务的约束–协议，其中传输层的任务就是负责为<strong>端到端连接提供可靠的传输服务</strong>，对应的传输层协议就是Tcp&#x2F;Udp协议。</p>
<p><strong>端口号：</strong></p>
<p>传输层端到端指的就是端口号，端口号是主机上进程的唯一标识。通过端口号，数据从传输层向应用层交付时，就知道数据该交给哪一个进程。</p>
<p><strong>套接字Socket：</strong></p>
<p>Socket &#x3D; IP地址：端口号，例如：433.25.25.25：8081</p>
<p>Socket标识着网络中一台主机上的一个进程</p>
<p><strong>无连接服务和面向连接服务：</strong></p>
<p>无连接服务指通信双方在进行通信之前，不需要进行连接操作，直接进行通信，从而提高通信的效率，但也因此不能保障通信的安全和可靠性。Udp协议就是提供无连接服务。</p>
<p>面向连接服务指通信双方在进行通信之前，先需要建立通信双方之间的连接，从而对双方的通信进行实时的监控和管理，因此能保障通信的安全和可靠性，但会导致通信的效率降低。Tcp协议就是提供面向连接服务。</p>
<h3 id="2-1-Udp协议"><a href="#2-1-Udp协议" class="headerlink" title="2.1 Udp协议"></a>2.1 Udp协议</h3><p>Udp协议提供无连接的数据报服务，一次发送一个报文，不对报文进行拆分和合并，而是保留这些报文的边界。</p>
<h4 id="Udp报头格式："><a href="#Udp报头格式：" class="headerlink" title="Udp报头格式："></a><strong>Udp报头格式：</strong></h4><p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.4.png"></p>
<ul>
<li>源&#x2F;目的端口：发送方&#x2F;接受方对应进程的端口号</li>
<li>总长度：报头+数据的长度</li>
<li>校验和：检验Udp报文是否传输中出错</li>
</ul>
<h3 id="2-2-Tcp协议"><a href="#2-2-Tcp协议" class="headerlink" title="2.2 Tcp协议"></a>2.2 Tcp协议</h3><p>Tcp协议提供面向连接的字节流服务，通信前需要连接双方之间的连接，对发送数据的每一个字节都进行了编号，保证传送的数据无差错、不丢失、有序，可以对报文进行拆分和合并。</p>
<h4 id="Tcp报头格式："><a href="#Tcp报头格式：" class="headerlink" title="Tcp报头格式："></a><strong>Tcp报头格式：</strong></h4><p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.3.png"></p>
<ul>
<li>源&#x2F;目的端口：发送方&#x2F;接受方对应进程的端口号</li>
<li>序号：数据部分的第一个字节的编号</li>
<li>确认号：接收方已经正确接收到的数据的最后一个字节的编号</li>
<li>数据偏移：4位，数据范围 0101 - 1111，单位是4B，即报头长度是20B - 60B</li>
<li>保留：保留字段，留作以后的使用</li>
<li>UGR：置1时表明紧急指针字段有效，操作系统尽快读取紧急指针指向的数据段</li>
<li>ACK：置1时表明确认号字段有效，Tcp协议规定在建立好连接后通信时，ACK段也必须置为1</li>
<li>PSH：置1时表明操作系统不需等待接收缓冲区满，直接读取数据</li>
<li>RST：置1时表明当前Tcp连接出错，重新建立连接</li>
<li>SYN：置1时表明这个Tcp报文是Tcp连接报文或Tcp确认连接报文</li>
<li>FIN：置1时表明这个是发送方断开连接请求</li>
<li>窗口：表明发送数据的速度，值 &#x3D; min （接收方接收能力，发送方所处网络的拥塞情况）</li>
<li>检验和：检验数据是否在传输过程出错</li>
</ul>
<h4 id="确认应答机制（ACK）："><a href="#确认应答机制（ACK）：" class="headerlink" title="确认应答机制（ACK）："></a>确认应答机制（ACK）：</h4><p>Tcp协议使用了确认应答机制来提高数据传输的可靠性，发送方会在Tcp报头的序号字段填写发送数据的第一个字节的编号，接受方在收到正确且有序的报文后，会在回复报文（ACK）的的确认号字段填上收到连续数据的最后一个字节编号，表明接收方已经正确收到了编号之前对应的所有数据，如果出现数据不连续的情况，例如收到了0-1000，2001-3000，3001-4000的Tcp报文，接收方就会在Tcp报文的确认好字段填上1001，表明编号1001后的报文没有收到，发送方会重传编号1001以后的Tcp报文，但此时会出现报文重复的情况，接收方会甄别并丢弃重复的Tcp报文。通过这种确认应答机制，可以保证数据的不丢失且有序。</p>
<h4 id="超时重传机制："><a href="#超时重传机制：" class="headerlink" title="超时重传机制："></a>超时重传机制：</h4><p>Tcp协议使用超时重传机制来解决传输过程中丢包的情况，发生以下几种情况时，会进行Tcp报文的重传：</p>
<ul>
<li>发送的报文因为网络拥塞等原因，无法到达接收方主机，发送方超过一段时间没收到ACK就会进行重传</li>
<li>接收方的ACK在网络拥塞等原因，无法到达发送方主机，发送方超过一段时间没收到ACK就会进行重传</li>
</ul>
<p>Linux为了保证无论在任何环境下都能比较高性能的通信, 因此会动态计算这个最大超时时间</p>
<blockquote>
<ul>
<li><p>Linux中 超时以500ms为一个单位进行控制, 每次判定超时重发的超时</p>
<p>时间都是500ms的整数倍</p>
</li>
<li><p>如果重发一次之后, 仍然得不到应答, 等待 2*500ms 后再进行重传</p>
</li>
<li><p>如果仍然得不到应答, 等待 4*500ms 进行重传. 依次类推, 以指数形式递增</p>
</li>
<li><p>累计到一定的重传次数, TCP认为网络或者对端主机出现异常, 强制关闭连接</p>
</li>
</ul>
</blockquote>
<h4 id="TCP流量控制（滑动窗口）："><a href="#TCP流量控制（滑动窗口）：" class="headerlink" title="TCP流量控制（滑动窗口）："></a>TCP流量控制（滑动窗口）：</h4><p>为了消除通信双方网络环境和数据处理能力带来的数据传输能力不一致的问题，TCP使用了滑动窗口来进行传输速率的控制。</p>
<p>在通信过程中，接收方会在Tcp报文的窗口字段填写自己的接收缓冲区的剩余大小（rwnd，接收窗口）来告诉发送方自己的数据接收能力，发送方在收到报文后，会再结合自身网络拥塞情况（cwnd，拥塞窗口）的情况，来动态调整发送窗口的大小。</p>
<p>发送窗口 &#x3D; min （rwnd，cwnd）</p>
<h4 id="TCP拥塞控制："><a href="#TCP拥塞控制：" class="headerlink" title="TCP拥塞控制："></a>TCP拥塞控制：</h4><p>TCP拥塞控制有两种算法：</p>
<ul>
<li><p>慢开始和拥塞避免</p>
<p>设立拥塞窗口阈值初始值为n</p>
<p>慢开始阶段：cwnd初始值为1，以2倍增长（2 4 8 16 …)  直到等于阈值n，开始拥塞避免阶段</p>
<p>拥塞避免阶段：线性增长，cwnd每次加1，直到出现网络拥塞，将拥塞窗口阈值设为此时cwnd的一半（假设出现网络拥塞时cwnd为							  34，则新的拥塞窗口阈值为17），然后将cwnd设为1，从新进入慢开始阶段</p>
</li>
<li><p>快恢复</p>
</li>
</ul>
<p>​	当出现冗余ACK的时候，采用快恢复算法，将拥塞窗口阈值设为此时cwnd的一半，与拥塞避免阶段不同的是，cwnd不是从1开始，而是直接从新的拥塞窗口阈值开始线性增长。</p>
<h4 id="TCP三次握手-x2F-四次挥手："><a href="#TCP三次握手-x2F-四次挥手：" class="headerlink" title="TCP三次握手&#x2F;四次挥手："></a>TCP三次握手&#x2F;四次挥手：</h4><p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.6.png"></p>
<p><strong>服务端状态转换：</strong></p>
<ul>
<li><p>[CLOSED -&gt; LISTEN] 服务器端调用listen后进入LISTEN状态, 等待客户端连接</p>
</li>
<li><p>[LISTEN -&gt; SYN_RCVD] 一旦监听到连接请求(同步报文段), 就将该连接放入内核等待队列中, 并向客户端发送SYN确认报文</p>
</li>
<li><p>[SYN_RCVD -&gt; ESTABLISHED] 服务端一旦收到客户端的确认报文, 就进入ESTABLISHED状态, 可以进行读写数据了</p>
</li>
<li><p>[ESTABLISHED -&gt; CLOSE_WAIT] 当客户端主动关闭连接(调用close), 服务器会收到结束报文段, 服务器返回确认报文段并进入CLOSE_WAIT</p>
</li>
<li><p>[CLOSE_WAIT -&gt; LAST_ACK] 进入CLOSE_WAIT后说明服务器准备关闭连接(需要处理完之前的数据); 当</p>
<p>服务器真正调用close关闭连接时, 会向客户端发送FIN, 此时服务器进入LAST_ACK状态, 等待最后一个</p>
<p>ACK到来(这个ACK是客户端确认收到了FIN)</p>
</li>
<li><p>[LAST_ACK -&gt; CLOSED] 服务器收到了对FIN的ACK, 彻底关闭连接</p>
</li>
</ul>
<p><strong>客户端状态转换：</strong></p>
<ul>
<li>[CLOSED -&gt; SYN_SENT] 客户端调用connect, 发送同步报文段</li>
<li>[SYN_SENT -&gt; ESTABLISHED] connect调用成功, 则进入ESTABLISHED状态, 开始读写数据</li>
<li>[ESTABLISHED -&gt; FIN_WAIT_1] 客户端主动调用close时, 向服务器发送结束报文段, 同时进入FIN_WAIT_1</li>
<li>[FIN_WAIT_1 -&gt; FIN_WAIT_2] 客户端收到服务器对结束报文段的确认, 则进入FIN_WAIT_2, 开始等待服务器的结束报文段</li>
<li>[FIN_WAIT_2 -&gt; TIME_WAIT] 客户端收到服务器发来的结束报文段, 进入TIME_WAIT, 并发出LAST_ACK</li>
<li>[TIME_WAIT -&gt; CLOSED] 客户端要等待一个2MSL(Max Segment Life, 报文最大生存时间)的时间, 才会进入CLOSED状态</li>
</ul>
<p><strong>TIME_WAIT状态：</strong></p>
<ul>
<li>TCP协议规定,主动关闭连接的一方要处于TIME_ WAIT状态,等待两个MSL(maximum segment lifetime)的时间后才能关闭</li>
<li>MSL是TCP报文的最大生存时间，设置为2MSL就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失</li>
<li>同时也是在理论上保证最后一个报文可靠到达(假设最后一个ACK丢失, 那么服务器会再重发一个FIN. 这时虽然客户端的进程不在了, 但是TCP连接还在, 仍然可以重发LAST_ACK)</li>
</ul>
<h2 id="3-Linux下Socket编程"><a href="#3-Linux下Socket编程" class="headerlink" title="3. Linux下Socket编程"></a>3. Linux下Socket编程</h2><h3 id="3-1-UdpSocket"><a href="#3-1-UdpSocket" class="headerlink" title="3.1 UdpSocket"></a>3.1 UdpSocket</h3><h4 id="3-1-1-socket"><a href="#3-1-1-socket" class="headerlink" title="3.1.1 socket"></a>3.1.1 socket</h4><p>Linux一切皆文件，我们进行网络通信时，也是通过专门的socket文件，该文件内部封装了各种用于处理网络通信的API。socket接口用于创建socket文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>domain 作用域 本地或网络</li>
</ul>
<blockquote>
<p>Name               					  Purpose                         				        Man page<br>AF_UNIX, AF_LOCAL  		  Local communication                          unix(7)<br>AF_INET             				    IPv4 Internet protocols                       ip(7)<br>AF_INET6           					IPv6 Internet protocols                       ipv6(7)<br>AF_IPX              					  IPX - Novell protocols<br>AF_NETLINK                          Kernel user interface device              netlink(7)<br>AF_X25                                   ITU-T X.25 &#x2F; ISO-8208 protocol          x25(7)<br>AF_AX25                                Amateur radio AX.25 protocol<br>AF_ATMPVC                          Access to raw ATM PVCs<br>AF_APPLETALK                     Appletalk                                               ddp(7)<br>AF_PACKET                           Low level packet interface                  packet(7)</p>
</blockquote>
<ul>
<li>type 报文类型</li>
</ul>
<blockquote>
<p>SOCK_STREAM   字节流 Tcp通信选项</p>
<p>SOCK_DGRAM    数据报 Udp通信选项</p>
<p>SOCK_RAW          原始格式</p>
</blockquote>
<ul>
<li>protocol  一般设为0</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>       On success, a file descriptor for the new socket is returned.  On error, -1 is returned, and errno is set appropriately.</p>
</blockquote>
<p>Socket接口创建socket文件，返回该文件的文件描述符(失败返回-1）。socket文件内部针对网络通信封装了各种API，字段，将网络通信转化为对文件的操作。</p>
<h4 id="3-1-2-bind"><a href="#3-1-2-bind" class="headerlink" title="3.1.2 bind"></a>3.1.2 bind</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *my_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>sockfd   socket文件描述符</li>
<li>my_addr  网络结构体，填充IP、IP协议类型、端口</li>
<li>addrlen  结构体大小</li>
</ul>
<h5 id="struct-sockaddr："><a href="#struct-sockaddr：" class="headerlink" title="struct sockaddr："></a>struct sockaddr：</h5><blockquote>
<p>由于早期c语言不支持void *，所以采用了统一的struct sockaddr结构体来接收不同类型的作用域结构体。我们需要将所选作用域结构体的字段填充好，再强转成 struct sockaddr * </p>
<p>IPv4协议对应的网络结构体 ：struct sockaddr_in     IPv6协议对应的网络结构体： struct socaddr_in6</p>
</blockquote>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.7.png"></p>
<p>bind会将my_addr结构体中的各个属性和进程进行绑定，my_addr中的IP字段作为进程所在主机的IP地址，端口字段作为该进程的标识符，到达传输层的报文就会根据端口号向应用层对应的进程交付数据</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.8.png"></p>
<h4 id="3-1-3-recvfrom"><a href="#3-1-3-recvfrom" class="headerlink" title="3.1.3 recvfrom"></a>3.1.3 recvfrom</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>sockfd  socket文件描述符</li>
<li>buf  接收数据缓冲区</li>
<li>len 缓冲区大小</li>
<li>flag  等待数据方式，0为阻塞等待</li>
<li>src_addr 输入输出型参数，可以获取客户端的IP和端口号</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>       These  calls  return the number of bytes received, or -1 if an error occurred.  In the event of an error, errno is set to indicate the error.  The return value<br>       will be 0 when the peer has performed an orderly shutdown.</p>
</blockquote>
<p>recvfrom会返回接收到数据的字节数</p>
<h4 id="3-1-4-sendto"><a href="#3-1-4-sendto" class="headerlink" title="3.1.4 sendto"></a>3.1.4 sendto</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>sockfd  socket文件描述符</li>
<li>buf  发送数据缓冲区</li>
<li>len   发送数据缓冲区大小</li>
<li>flags  一般设为0</li>
<li>dest_addr 输入型参数，向服务器发送本地的IP和进程对应的端口号</li>
</ul>
<p>以下是一个基于Udp套接字编写的客户端&#x2F;服务端简单实例</p>
<p><strong>服务端：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Udpserver</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Udpserver</span>(<span class="type">uint16_t</span> port, std::string ip = <span class="string">&quot;&quot;</span>)</span><br><span class="line">        : <span class="built_in">port_</span>(port), <span class="built_in">ip_</span>(ip), <span class="built_in">sockfd_</span>(<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sockfd_ = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sockfd_ &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log</span>(FATAL, <span class="string">&quot;create server socket err&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;</span><br><span class="line">        local.sin_addr.s_addr = ip_.<span class="built_in">empty</span>() ? <span class="built_in">htonl</span>(INADDR_ANY) : <span class="built_in">inet_addr</span>(ip_.<span class="built_in">c_str</span>());</span><br><span class="line">        local.sin_family = AF_INET;</span><br><span class="line">        local.sin_port = port_;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd_, (<span class="type">const</span> sockaddr *)&amp;local, <span class="built_in">sizeof</span>(local)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log</span>(FATAL, <span class="string">&quot;server bind socket err&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>(DEBUG,<span class="string">&quot;server bind success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 输出型参数</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;</span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line">            <span class="type">ssize_t</span> s = <span class="built_in">recvfrom</span>(sockfd_, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;peer, &amp;len);</span><br><span class="line">            <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                buffer[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">log</span>(WARNING, <span class="string">&quot;recvfrom fail&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">log</span>(INFO, <span class="string">&quot;[%s:%d]# %s&quot;</span>, <span class="built_in">inet_ntoa</span>(peer.sin_addr), <span class="built_in">ntohs</span>(peer.sin_port), buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string ip_;</span><br><span class="line">    std::<span class="type">uint16_t</span> port_;</span><br><span class="line">    <span class="type">int</span> sockfd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> &amp;&amp; argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(FATAL, <span class="string">&quot;usage:[%s port [ip]]&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ./server port</span></span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Udpserver <span class="built_in">server</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line">            server.<span class="built_in">loop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ./server port ip</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Udpserver <span class="built_in">server</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]);</span><br><span class="line">            server.<span class="built_in">loop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Udpclient</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Udpclient</span>(std::<span class="type">uint16_t</span> port, std::string ip)</span><br><span class="line">        : <span class="built_in">ip_</span>(ip), <span class="built_in">port_</span>(port), <span class="built_in">sockfd_</span>(<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sockfd_ = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sockfd_ &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log</span>(FATAL, <span class="string">&quot;create client socket err&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// client不需要手动bind，操作系统会自动bind</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;</span><br><span class="line">        <span class="built_in">bzero</span>(&amp;local,<span class="built_in">sizeof</span>(local));</span><br><span class="line">        local.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip_.<span class="built_in">c_str</span>());</span><br><span class="line">        local.sin_family = AF_INET;</span><br><span class="line">        local.sin_port = port_;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;Enter# &quot;</span>;</span><br><span class="line">            std::string buffer;</span><br><span class="line">            <span class="built_in">getline</span>(std::cin,buffer);</span><br><span class="line">            <span class="built_in">sendto</span>(sockfd_, buffer.<span class="built_in">c_str</span>(), buffer.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;local, <span class="built_in">sizeof</span>(local));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string ip_;</span><br><span class="line">    std::<span class="type">uint16_t</span> port_;</span><br><span class="line">    <span class="type">int</span> sockfd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Udpclient <span class="title">client</span><span class="params">(atoi(argv[<span class="number">1</span>]),argv[<span class="number">2</span>])</span></span>;</span><br><span class="line">        client.<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">log</span>(FATAL,<span class="string">&quot;Usage:[%s port ip]&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是运行截图：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.9.png"></p>
<h3 id="3-2-TcpSocket"><a href="#3-2-TcpSocket" class="headerlink" title="3.2 TcpSocket"></a>3.2 TcpSocket</h3><p>Tcp提供面向连接的可靠的服务，因此进行通信前需要先建立连接</p>
<p>对于服务端 ：socket（创建套接字）  -&gt;  bind （和进程关联）-&gt;  listen(监听)  -&gt;  accept (建立连接)  -&gt;  read&#x2F;write (通信) </p>
<p>对于客户端： socket（创建套接字）  -&gt;  bind （和进程关联）-&gt;  connect(连接请求)   -&gt;  read&#x2F;write (通信) </p>
<h4 id="3-2-1-listen"><a href="#3-2-1-listen" class="headerlink" title="3.2.1 listen"></a>3.2.1 listen</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>s  监听socket文件描述符</li>
<li>backlog   缓存连接队列的最大容量，暂未建立连接的连接请求会放到这个队列中</li>
</ul>
<h4 id="3-2-1-accept"><a href="#3-2-1-accept" class="headerlink" title="3.2.1 accept"></a>3.2.1 accept</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>s  ：监听socket文件描述符</li>
<li>addr ：作用域结构体</li>
<li>addrlen：结构体的大小</li>
</ul>
<p>accept会将listen监听到的客户端发来的连接请求报文做处理后，发送连接答复报文给客户端，再收到客户端的确认应答之后，即连接建立成功，accept会创建一个新的socket文件并返回这个socket文件的文件描述符，用于服务端和该客户端进行通信。</p>
<blockquote>
<p>DESCRIPTION 描述<br>       accept      函数用于基于连接的套接字(SOCK_STREAM, SOCK_SEQPACKET和 SOCK_RDM).它从未完成连接队列中取出第一个连接请求,创建一个和参数s 属性相同的连接套接字,并为这个套接字分配一个文件描述符, 然后以这个描述符返回.新创建的描述符不再处于倾听状态.原  套接字  s  不受此调用的影响.注意任意一个文件描述符标志 (任何可以被 fcntl以参数 F_SETFL 设置的值,比如非阻塞式或者异步状态)不会被accept所继承.</p>
<pre><code>如果队列中没有未完成连接套接字,并且套接字没有标记为非阻塞式,accept将阻塞直到一个连接到达.如果一个套接字被标记为非阻塞式而队列中没有未完成连接套接字,accept将返回EAGAIN.使用select或者poll可以在一个套接字上有连接到来时产生事件.当尝试一个新的连接时套接字读就绪,这样我们就可以调用accept为这个连接获得一个新的套接字.此外,你还可以设置套接字在唤醒时接收到信号 SIGIO
</code></pre>
</blockquote>
<h4 id="3-2-1-connect"><a href="#3-2-1-connect" class="headerlink" title="3.2.1 connect"></a>3.2.1 connect</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>sockfd：socket 文件描述符</li>
<li>addr ：作用域结构体</li>
<li>addrlen：结构体的大小</li>
</ul>
<p>以下是一个简单的Tcp服务端和客户端的示例：</p>
<p><strong>头文件：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>服务端：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tcpserver</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tcpserver</span>(<span class="type">uint16_t</span> port, std::string ip = <span class="string">&quot;&quot;</span>)</span><br><span class="line">        : <span class="built_in">port_</span>(port), <span class="built_in">ip_</span>(ip), <span class="built_in">listenfd_</span>(<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        listenfd_ = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (listenfd_ &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log</span>(FATAL, <span class="string">&quot;create Tcpserver socket err&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;</span><br><span class="line">        local.sin_addr.s_addr = ip.<span class="built_in">empty</span>() ? <span class="built_in">htonl</span>(INADDR_ANY) : <span class="built_in">inet_addr</span>(ip.<span class="built_in">c_str</span>());</span><br><span class="line">        local.sin_port = <span class="built_in">htons</span>(port_);</span><br><span class="line">        local.sin_family = AF_INET;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd_, (<span class="type">const</span> sockaddr *)&amp;local, <span class="built_in">sizeof</span>(local)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log</span>(FATAL, <span class="string">&quot;Tcpserver bind err&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>(DEBUG, <span class="string">&quot;server bind success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">tranService</span><span class="params">(ConnClient *conn)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line">            <span class="type">ssize_t</span> s = <span class="built_in">read</span>(conn-&gt;sockfd_, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">            <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                buffer[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="built_in">log</span>(INFO, <span class="string">&quot;[%s:%d]# %s&quot;</span>, conn-&gt;ip_.<span class="built_in">c_str</span>(), conn-&gt;port_, buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 客户端退出，close fd</span></span><br><span class="line">                <span class="built_in">close</span>(conn-&gt;sockfd_);</span><br><span class="line">                <span class="built_in">log</span>(DEBUG, <span class="string">&quot;[%s:%d exit]&quot;</span>, conn-&gt;ip_.<span class="built_in">c_str</span>(), conn-&gt;port_);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 启动线程池</span></span><br><span class="line">        pool = Threadpool::<span class="built_in">GetInstance</span>(<span class="number">12</span>);</span><br><span class="line">        pool-&gt;<span class="built_in">loop</span>();</span><br><span class="line">        <span class="comment">// Tcp面向连接，listen 监听连接请求</span></span><br><span class="line">        <span class="built_in">listen</span>(listenfd_, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 创建epoll  注册监听事件</span></span><br><span class="line">        <span class="function">Epoll <span class="title">epoll</span><span class="params">(listenfd_)</span></span>;</span><br><span class="line">        <span class="function">TcpSocket <span class="title">ts</span><span class="params">(ip_, port_, listenfd_)</span></span>;</span><br><span class="line">        epoll.<span class="built_in">Add</span>(ts);</span><br><span class="line">        <span class="comment">// 事件循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::vector&lt;TcpSocket&gt; FdWaitQueue;</span><br><span class="line">            <span class="keyword">if</span> (!epoll.<span class="built_in">Wait</span>(FdWaitQueue))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;elem : FdWaitQueue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 监听事件就绪，创建连接</span></span><br><span class="line">                <span class="keyword">if</span> (elem.sockfd_ == listenfd_)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;</span><br><span class="line">                    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line">                    <span class="type">int</span> sockfd = <span class="built_in">accept</span>(listenfd_, (<span class="keyword">struct</span> sockaddr *)&amp;peer, &amp;len);</span><br><span class="line">                    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">log</span>(DEBUG, <span class="string">&quot;accept err&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        TcpSocket <span class="built_in">ts</span>(<span class="built_in">inet_ntoa</span>(peer.sin_addr), <span class="built_in">ntohs</span>(peer.sin_port), sockfd);</span><br><span class="line">                        epoll.<span class="built_in">Add</span>(ts);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ConnClient *conn = <span class="keyword">new</span> <span class="built_in">ConnClient</span>(elem.sockfd_, elem.port_, elem.ip_);</span><br><span class="line">                    pool-&gt;<span class="built_in">addTask</span>(tranService, conn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Tcpserver</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(listenfd_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> listenfd_;</span><br><span class="line">    std::string ip_;</span><br><span class="line">    <span class="type">uint16_t</span> port_;</span><br><span class="line">    <span class="type">static</span> Threadpool *pool;</span><br><span class="line">&#125;;</span><br><span class="line">Threadpool *Tcpserver::pool = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span> &amp;&amp; argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(FATAL, <span class="string">&quot;Usage:%s [port:ip]&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Tcpserver <span class="title">svr</span><span class="params">(atoi(argv[<span class="number">1</span>]))</span></span>;</span><br><span class="line">        svr.<span class="built_in">loop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::string ip = argv[<span class="number">2</span>];</span><br><span class="line">        <span class="function">Tcpserver <span class="title">svr</span><span class="params">(atoi(argv[<span class="number">1</span>]), ip)</span></span>;</span><br><span class="line">        svr.<span class="built_in">loop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tcpclient</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tcpclient</span>(<span class="type">uint16_t</span> port,std::string ip)</span><br><span class="line">    :<span class="built_in">port_</span>(port)</span><br><span class="line">    ,<span class="built_in">ip_</span>(ip)</span><br><span class="line">    ,<span class="built_in">sockfd_</span>(<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sockfd_ = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sockfd_ &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log</span>(FATAL,<span class="string">&quot;client create socket err&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由操作系统来完成bind</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local;</span><br><span class="line">        <span class="built_in">bzero</span>(&amp;local,<span class="built_in">sizeof</span>(local));</span><br><span class="line">        local.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip_.<span class="built_in">c_str</span>());</span><br><span class="line">        local.sin_family = AF_INET;</span><br><span class="line">        local.sin_port = <span class="built_in">htons</span>(port_);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">connect</span>(sockfd_,(<span class="type">const</span> <span class="keyword">struct</span> sockaddr*)&amp;local,<span class="built_in">sizeof</span>(local)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log</span>(FATAL,<span class="string">&quot;connect to server err&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;echo# &quot;</span>;</span><br><span class="line">            std::string buffer;</span><br><span class="line">            <span class="built_in">getline</span>(std::cin,buffer);</span><br><span class="line">            <span class="keyword">if</span>(buffer == <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write</span>(sockfd_,buffer.<span class="built_in">c_str</span>(),buffer.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Tcpclient</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(DEBUG,<span class="string">&quot;close&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd_);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> sockfd_;</span><br><span class="line"><span class="type">uint16_t</span> port_;</span><br><span class="line">std::string ip_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(FATAL,<span class="string">&quot;Usage:%s port:ip&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Tcpclient <span class="title">client</span><span class="params">(atoi(argv[<span class="number">1</span>]),argv[<span class="number">2</span>])</span></span>;</span><br><span class="line">    client.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Task.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Threadpool</span>(<span class="type">int</span> threadNum);</span><br><span class="line">    <span class="built_in">Threadpool</span>(<span class="type">const</span> Threadpool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Threadpool &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Threadpool &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Threadpool</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获得线程池单例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Threadpool *<span class="title">GetInstance</span><span class="params">(<span class="type">int</span> threadNum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Double Check Lock</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;Mutex);</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Threadpool</span>(threadNum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;Mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum_; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, run, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务到任务队列</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(<span class="type">void</span> (*func)(ConnClient *), ConnClient *args)</span></span>;</span><br><span class="line">    <span class="comment">// 添加空任务到任务队列</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">joinAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">run</span><span class="params">(<span class="type">void</span> *args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Threadpool *instance;</span><br><span class="line">    std::queue&lt;Task *&gt; Taskqueue; <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> queueMutex;   <span class="comment">// 锁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> Mutex; <span class="comment">// 单例锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> queueCond;     <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="type">pthread_t</span> *threads;</span><br><span class="line">    <span class="type">int</span> threadNum_; <span class="comment">// 线程数量</span></span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line">Threadpool *Threadpool::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> Threadpool::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Threadpool::addTask</span><span class="params">(<span class="type">void</span> (*func)(ConnClient *), ConnClient *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task *task = <span class="keyword">new</span> <span class="built_in">Task</span>(func, args);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;queueMutex);</span><br><span class="line">    Taskqueue.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="comment">// 通知消费者消费</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;queueCond);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;queueMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Threadpool::~<span class="built_in">Threadpool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    <span class="built_in">pthread_cond_broadcast</span>(&amp;queueCond);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] threads;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;queueMutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;queueCond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Threadpool::run</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;instance-&gt;queueMutex);</span><br><span class="line">        <span class="keyword">while</span> (instance-&gt;Taskqueue.<span class="built_in">empty</span>() &amp;&amp; !instance-&gt;stop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待线程被唤醒</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;instance-&gt;queueCond, &amp;instance-&gt;queueMutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (instance-&gt;stop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;instance-&gt;queueMutex);</span><br><span class="line">            <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Task *task = instance-&gt;Taskqueue.<span class="built_in">front</span>();</span><br><span class="line">        instance-&gt;Taskqueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;instance-&gt;queueMutex);</span><br><span class="line">        <span class="keyword">if</span> (task)</span><br><span class="line">        &#123;</span><br><span class="line">            task-&gt;<span class="built_in">func_</span>(task-&gt;args_);</span><br><span class="line">            <span class="keyword">delete</span> task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队列添加空任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Threadpool::joinAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">addTask</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Threadpool::<span class="built_in">Threadpool</span>(<span class="type">int</span> threadNum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;threadNum_ = threadNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;queueMutex, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;queueCond, <span class="literal">nullptr</span>);</span><br><span class="line">    threads = <span class="keyword">new</span> <span class="type">pthread_t</span>[threadNum];</span><br><span class="line">    stop = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>epoll：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpSocket</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string ip_;</span><br><span class="line">    <span class="type">uint16_t</span> port_;</span><br><span class="line">    <span class="type">int</span> sockfd_;</span><br><span class="line">    <span class="type">bool</span> exit_;</span><br><span class="line">    <span class="built_in">TcpSocket</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">TcpSocket</span>(std::string ip, <span class="type">uint16_t</span> port, <span class="type">int</span> fd)</span><br><span class="line">        : <span class="built_in">ip_</span>(ip), <span class="built_in">port_</span>(port),<span class="built_in">sockfd_</span>(fd), <span class="built_in">exit_</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;TcpSocket&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> TcpSocket &amp;socket)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(socket.sockfd_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> TcpSocket &amp;lhs, <span class="type">const</span> TcpSocket &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.sockfd_ == rhs.sockfd_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件操作设置为非阻塞</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNonBlock</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获得文件描述符的标志  open(src_path,O_APPEND | O_CREATE);</span></span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (flags &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoll</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Epoll</span>(<span class="type">int</span> listenfd)</span><br><span class="line">    &#123;</span><br><span class="line">        listenfd_ = listenfd;</span><br><span class="line">        epoll_fd = <span class="built_in">epoll_create</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Epoll</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> TcpSocket socket)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 添加索引</span></span><br><span class="line">        indexMap[socket.sockfd_] = socket;</span><br><span class="line">        epoll_event event;</span><br><span class="line">        event.data.fd = socket.sockfd_;</span><br><span class="line">        <span class="comment">// EPOLLIN: 可以对该文件执行读操作</span></span><br><span class="line">        <span class="comment">// EPOLLOUT 可以对该文件执行写操作</span></span><br><span class="line">        <span class="comment">// EPOLLERR：表示对应文件描述符上出现了错误。</span></span><br><span class="line">        <span class="comment">// EPOLLHUP：poll:表示对应文件描述符上出现了挂起事件，如连接断开或对端关闭连接。</span></span><br><span class="line">        <span class="comment">// EPOLLRDHUP：epoll:表示对应文件描述符上的连接已被对端关闭或重置。</span></span><br><span class="line">        <span class="comment">// EPOLLET：表示使用边缘触发模式。</span></span><br><span class="line">        <span class="comment">// EPOLLONESHOT：表示使用一次性触发模式。</span></span><br><span class="line">        event.events = EPOLLIN;</span><br><span class="line">        <span class="comment">// int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span></span><br><span class="line">        <span class="comment">// op： EPOLL_CTL_ADD 注册新的fd  EPOLL_CTL_MOD 修改fd的事件 EPOLL_CTL_DEL 删除epfd中的fd</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, socket.sockfd_, &amp;event) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll add fd&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>(DEBUG, <span class="string">&quot;Epoll Add [%d]&quot;</span>, socket.sockfd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Del</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;sockfd)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, sockfd, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll del fd&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Wait</span><span class="params">(std::vector&lt;TcpSocket&gt; &amp;output)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        output.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 存储就绪事件对应的fd</span></span><br><span class="line">        epoll_event Events[<span class="number">100</span>];</span><br><span class="line">        <span class="comment">// 返回就绪事件的数量</span></span><br><span class="line">        <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, Events, <span class="built_in">sizeof</span>(Events), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nfds == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对端退出</span></span><br><span class="line">            <span class="keyword">if</span> (Events[i].data.fd != listenfd_)</span><br><span class="line">            &#123;</span><br><span class="line">                output.<span class="built_in">push_back</span>(indexMap[Events[i].data.fd]);</span><br><span class="line">                indexMap.<span class="built_in">erase</span>(Events[i].data.fd);</span><br><span class="line">                <span class="built_in">Del</span>(Events[i].data.fd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对端连接</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                output.<span class="built_in">push_back</span>(indexMap[Events[i].data.fd]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> epoll_fd;</span><br><span class="line">    <span class="type">int</span> listenfd_;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, TcpSocket&gt; indexMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>任务类：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConnClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ConnClient</span>(<span class="type">int</span> sockfd, <span class="type">uint16_t</span> port, <span class="type">const</span> std::string ip)</span><br><span class="line">        : <span class="built_in">sockfd_</span>(sockfd), <span class="built_in">port_</span>(port), <span class="built_in">ip_</span>(ip)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sockfd_;</span><br><span class="line">    <span class="type">uint16_t</span> port_;</span><br><span class="line">    std::string ip_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Task</span>(<span class="built_in">void</span> (*func)(ConnClient *), ConnClient *args)</span><br><span class="line">        : <span class="built_in">args_</span>(args), <span class="built_in">func_</span>(func)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Task</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> args_;</span><br><span class="line">    &#125;</span><br><span class="line">    ConnClient *args_;</span><br><span class="line">    <span class="built_in">void</span> (*func_)(ConnClient *); <span class="comment">// 任务函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>C++三大特性（封装、继承、多态）</title>
    <url>/2023/05/18/c++%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-C-基础"><a href="#1-C-基础" class="headerlink" title="1. C++基础"></a>1. C++基础</h2><h4 id="1-1-命名空间"><a href="#1-1-命名空间" class="headerlink" title="1.1 命名空间"></a>1.1 命名空间</h4><blockquote>
<p>命名空间的目的是<strong>对标识符的名称进行本地化</strong>，以<strong>避免命名冲突或名字污染</strong>，c++提供了namespace关键字设置命名空间</p>
</blockquote>
<p>namespace的使用：</p>
<ul>
<li>定义方式：namespace + 空间名 + {}</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myspace &#123; <span class="comment">/* Your Code*/</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>命名空间可以嵌套</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myspace1&#123;</span><br><span class="line">    <span class="keyword">namespace</span> myspace2&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>命名空间内成员的使用 <strong>( 3种方式 )</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myspace&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><h6 id="空间名称-作用域限定符-：："><a href="#空间名称-作用域限定符-：：" class="headerlink" title="空间名称 + 作用域限定符 ：："></a>空间名称 + 作用域限定符 ：：</h6></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,myspace::a);   myspace::<span class="built_in">f</span>(); </span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h6 id="using-空间名-：：成员名"><a href="#using-空间名-：：成员名" class="headerlink" title="using  空间名 ：：成员名"></a>using  空间名 ：：成员名</h6></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> myspace::a;</span><br><span class="line"><span class="function"><span class="keyword">using</span> <span class="title">myspace::f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h6 id="using-空间名-释放空间内的所有成员，一般不建议"><a href="#using-空间名-释放空间内的所有成员，一般不建议" class="headerlink" title="using 空间名 (释放空间内的所有成员，一般不建议)"></a>using 空间名 (释放空间内的所有成员，一般不建议)</h6></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> myspace;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-缺省参数"><a href="#1-2-缺省参数" class="headerlink" title="1.2 缺省参数"></a>1.2 缺省参数</h4><blockquote>
<p>缺省参数（c编译器不支持）是<strong>声明或定义函数时</strong>为函数的<strong>参数指定一个缺省值</strong>。在调用该函数时，如果没有指定实参则采用</p>
<p>该形参的<strong>缺省值</strong>，否则使用指定的实参</p>
</blockquote>
<ul>
<li>缺省参数必须从右往左依次给出，且必须连续</li>
<li>缺省参数不能在函数声明和定义中同时出现，会导致编译器无法获取缺省值</li>
<li>缺省值必须是常量和全局变量</li>
</ul>
<h4 id="1-3-函数重载"><a href="#1-3-函数重载" class="headerlink" title="1.3 函数重载"></a>1.3 函数重载</h4><blockquote>
<p>函数重载指c++中<strong>同一作用域内</strong>数个功能类似但<strong>形参列表不同</strong>的<strong>同名函数</strong>，通常用于函数功能相同但参数不同的场景。</p>
</blockquote>
<p>构成函数重载的条件：</p>
<ul>
<li>形参个数不同</li>
<li>形参类型不同</li>
<li>形参顺序不同</li>
</ul>
<p><strong>函数重载的实现原理 – 名字修饰</strong></p>
<p>c++编译器在编译后会对函数名字做修饰，以Linux下g++编译器为例，会以如下格式对函数名进行修饰：</p>
<blockquote>
<p>函数修饰名：  _Z + 函数长度 + 函数名 + 类型首字母</p>
</blockquote>
<p>如下图所示，参数加入到了函数修饰的规则中，因此当函数参数列表不同时，对应的修饰函数名也不用，所以在进行函数调用时，就能正确的找到函数的地址：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/5.1.png"></p>
<p>而使用c编译器，例如gcc时，函数名就是原函数名，所以只要函数名相同，不论函数形参列表是否相同，c编译器都会认为是同一个函数，这就导致调用时出错，不知道该调用哪个函数，因此c编译器不支持函数重载。gcc编译器函数名修饰如下图所示：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/5.0.png"></p>
<p><strong>extern “C” :</strong></p>
<p>由于c&#x2F;c++编译器的修饰规则不同的原因，当出现c&#x2F;c++需要调用彼此库函数的时候，就会出现各种错误。</p>
<p>在制作c语言静态库时，可以在函数前加上 extern”C” ,告诉c++编译器以c的修饰规则来修饰这些函数名的，进行链接时，链接器就会以c的修饰规则去找到函数地址。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是c++工程</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-inline（内联函数）"><a href="#1-4-inline（内联函数）" class="headerlink" title="1.4 inline（内联函数）"></a>1.4 inline（内联函数）</h4><p>以inlin修饰的函数称为内联函数，c++编译器会在调用内联函数处直接展开代码，不会创建函数栈帧，以空间换时间的方式来提高运行效率。不同编译器对inline的实现机制可能存在差异，</p>
<ul>
<li>inline函数适用于规模较小、不涉及递归、频繁调用的函数，否则编译器会忽略inline属性</li>
<li>inline函数不能进行声明和定义分离，链接时，由于调用处直接展开，没有函数地址，导致链接失败</li>
</ul>
<h2 id="2-类和对象"><a href="#2-类和对象" class="headerlink" title="2. 类和对象"></a>2. 类和对象</h2><h4 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h4><blockquote>
<p><strong>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行</strong></p>
<p><strong>交互。封装本质上是一种管理，让用户更方便使用类</strong></p>
</blockquote>
<h4 id="2-2-类的引入"><a href="#2-2-类的引入" class="headerlink" title="2.2 类的引入"></a>2.2 类的引入</h4><p>C语言中，struct结构体只能定义变量，不能定义函数。C++中，struct结构体变量和函数都能定义，这便是C++的类的特性。在C++中，有专门的<strong>class关键字</strong>来表示类，之所以struct也可以表示类，是C++为了更好的兼容C语言。当然，class和struct也有一点区别：</p>
<ul>
<li>class默认的访问权限是private，struct默认的访问权限是public</li>
</ul>
<h4 id="2-3-类的作用域"><a href="#2-3-类的作用域" class="headerlink" title="2.3 类的作用域"></a>2.3 类的作用域</h4><p>类定义了一个独立的作用域，类中的成员变量和成员函数作用于类的作用域中，在类外使用成员变量和成员函数时，需要使用作用于限定符<code>::</code>来指定属于哪个类域</p>
<h4 id="2-4-类的定义"><a href="#2-4-类的定义" class="headerlink" title="2.4 类的定义"></a>2.4 类的定义</h4><p>以下是一个Person类的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name_;</span><br><span class="line">    <span class="type">char</span> *gender_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;name_&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;gender_&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;age_</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述类中，定义了3个成员变量（name_,gender_,age_) ，声明了一个成员函数show，其中<code>public</code>  和  <code>private</code>是<strong>访问限定符</strong></p>
<p>注意，上述Person类只在类体中声明了成员函数，是在类体外进行成员函数的定义，这也是推荐的一种做法，因为直接在类中定义成员函数，会被编译器处理成inline函数 </p>
<h4 id="2-5-访问限定符"><a href="#2-5-访问限定符" class="headerlink" title="2.5 访问限定符"></a>2.5 访问限定符</h4><blockquote>
<p>访问限定符的作用是将类内封装的成员和函数选择性的提供给类外使用，共设有三种访问权限：public、protected、private</p>
</blockquote>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/5.2.png"></p>
<ul>
<li><strong>public</strong>属性的成员或函数可以在类外通过<strong>作用域限定符</strong>和对象进行访问，而protected属性和private属性无法在类外直接访问</li>
<li>·访问限定符的作用范围是从定义处直到下一个访问限定符</li>
<li>class默认访问限定符是private，struct默认访问限定符是public(为了更好的兼容C语言)</li>
<li>访问限定符只对编译器有效，内存上不同属性的成员是没有区别的</li>
</ul>
<h4 id="2-6-对象"><a href="#2-6-对象" class="headerlink" title="2.6 对象"></a>2.6 对象</h4><blockquote>
<p>作用域+属性+方法构成了类，类是事物描述的集合，没有事物的实体。对象是类的实例化，它是实体，有实际的物理空间去存放类中描述的属性和方法。说人话就是，类是图纸，对象是根据图纸造出来的实体建筑</p>
</blockquote>
<p><strong>对象的存储方式：</strong></p>
<p>每个对象只保存成员变量,成员函数放在公共代码区，减少空间浪费.</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/5.3.png"></p>
<h4 id="2-7-结构体对齐"><a href="#2-7-结构体对齐" class="headerlink" title="2.7 结构体对齐"></a>2.7 结构体对齐</h4><p>结构体对齐是编译器在类实例化对象时为对象分配内存空间大小的一种规则，采用这种规则是为了<strong>方便C++编译器进行内存的分配和回收</strong></p>
<p>以VC编译器的内存分配为例：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/5.4.png"></p>
<p>上图分别表示了Complex对象和String对象分别在Debug（左）和release（右）模式下占用内存空间的大小。</p>
<p>以Debug模式下的Complex对象为例:</p>
<ul>
<li><p>内存空间上下有一对cookie，除了第一位其他位用来表示这段内存空间大小，第一位是标记位，0标识这段内存空间未使用，1标识已使用，共占8字节，</p>
</li>
<li><p>红色箭头所指的两处是编译器Debug模式下固定带的36字节数据</p>
</li>
<li><p>黄色部分就是对象的大小</p>
</li>
<li><p>pad部分是对齐所占空间，目的是保证内存空间分配是16的倍数，这样初始时cookie的第一位就一定是0，这样就可以用来标记内存空间的状态了</p>
</li>
</ul>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/5.6.png"></p>
<p>结构体对齐的规则：</p>
<p>默认对齐数：编译器设置的默认参数，不同编译器对应的对齐数可能不一样</p>
<p>实际对齐数：min（默认对齐数，该成员大小） （实际对齐数是动态调整的）</p>
<p>成员起始地址偏移量为0，随后成员的地址偏移量+1是实际对齐数的倍数</p>
<p>结构体总大小：最大对齐数（默认对齐数和所有实际对齐数的最大值）的整数倍</p>
<h4 id="2-8-this指针"><a href="#2-8-this指针" class="headerlink" title="2.8 this指针"></a>2.8 this指针</h4><blockquote>
<p>C++强制将普通类成员函数的第一个参数设置成了默认的this指针(const,不可修改)，该指针指向了类实例化出来的某个对象，通过this指针就可以对对象中的成员进行一个</p>
</blockquote>
<ul>
<li>this指针是成员函数的<strong>隐含</strong>的第一个形参，由编译器通过ecx寄存器传递参数值</li>
<li>对象调用成员函数时，会将将对象地址作为实参传递给this指针，就可以通过this指针访问对象的成员变量</li>
</ul>
<p><strong>为什么需要this指针？</strong></p>
<p>因为C++的对象存储方式，对象内部只存了成员变量，成员函数是放在了公共代码区，所以成员函数没法直接访问对象内的成员变量，因此C++为成员函数设置了一个默认this指针形参，通过this指针去访问成员变量，而将this指针设为强制的隐含形参，也是避免程序员自己去设置</p>
<h2 id="3-继承和多态"><a href="#3-继承和多态" class="headerlink" title="3. 继承和多态"></a>3. 继承和多态</h2>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下多线程编程及pthread库的使用</title>
    <url>/2023/04/26/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Linux下的线程"><a href="#1-Linux下的线程" class="headerlink" title="1. Linux下的线程"></a>1. Linux下的线程</h2><h4 id="1-1-Linux下线程与进程的关系"><a href="#1-1-Linux下线程与进程的关系" class="headerlink" title="1.1 Linux下线程与进程的关系"></a>1.1 Linux下线程与进程的关系</h4><ul>
<li><p><strong>进程是操作系统分配资源的基本单位</strong></p>
</li>
<li><p><strong>线程是操作系统任务调度的基本单位</strong></p>
</li>
<li><p><strong>Linux内核中的线程可以看作是轻量级进程</strong></p>
</li>
<li><p><strong>进程具有独立性，线程不具有独立性</strong></p>
<p>我们知道，Linux内核在创建<strong>进程</strong>时：</p>
<ol>
<li>创建并初始化<strong>进程控制块 PCB（Process Control Block）</strong>：它记录了进程的状态、标识符、优先级等。</li>
<li>为进程分配独立的虚拟进程地址空间，将程序、数据、库文件载入虚拟地址空间中。</li>
<li>复制父进程的内存空间：因为Linux采取了<strong>写时拷贝COW（Copy-On-Write）</strong>的技术，该进程的内存页表是父进程内存页表的一份拷贝，只有子进程需要修改其中某个内存页时，子进程的内存页表才会重新建立内存页表到物理空间的映射</li>
<li>复制父进程的文件描述符表</li>
<li>复制父进程的环境变量和命令行参数</li>
<li>复制父进程的信号处理器</li>
</ol>
<p>而Linux内核在创建<strong>线程</strong>时：</p>
<p>  1.初始化线程控制块（Thread Control Block，TCB）</p>
<p>  2.设置线程的堆栈、寄存器</p>
<p>  3.设置线程的调度属性</p>
<p>  4.加入到进程的线程组中，这些线程共享进程的部分资源</p>
<p>这些创建出来的线程不创建地址空间，而是<strong>共享进程的地址空间和其他资源</strong>（文件描述符，信号处理器等），其创建的开销远小于进程，所以我们说Linux下线程可以看作是轻量级进程。</p>
<p>进程拥有自己独立的进程地址空间，进程具有独立性，而线程共享进程的地址空间，所有线程不具有独立性。线程除了共享进程地址空间，也拥有自己的私有成员：线程标识符、线程栈、线程寄存器</p>
<p><strong>线程栈和线程寄存器是线程的两个重要组成部分：</strong></p>
<ul>
<li>线程栈是一个特殊的内存区域，用于存储线程执行时的函数调用栈、局部变量、函数参数等数据。每个线程都有自己的线程栈，线程栈的大小在创建线程时可以指定。线程在执行过程中，会不断地向线程栈中压入和弹出函数调用的相关信息，从而实现程序的正常执行。</li>
<li>线程寄存器是CPU中的一组特殊寄存器，用于存储线程执行时的上下文信息，包括程序计数器、栈指针、通用寄存器等。线程在执行过程中，需要不断地保存和恢复这些寄存器的值，以便在线程切换时保持线程的执行状态。</li>
</ul>
<p>在Linux系统中，线程栈和线程寄存器是由内核进行管理和调度的。线程栈和线程寄存器的分配和初始化工作是由内核在创建线程时完成的，当线程被切换时，内核会将线程栈和线程寄存器中的内容保存下来，然后切换到其他线程的执行上下文。因此，线程栈和线程寄存器的正确使用和管理对于线程的正常运行至关重要。</p>
</li>
</ul>
<h4 id="1-2-Linux下线程的种类"><a href="#1-2-Linux下线程的种类" class="headerlink" title="1.2  Linux下线程的种类"></a>1.2  Linux下线程的种类</h4><ol>
<li>用户级线程（User-Level Thread，ULT）：这种线程是由用户空间的线程库（<strong>如 pthread库</strong>）实现的，线程的创建、调度、同步等都由线程库管理。内核对用户级线程是没有感知的，因此它们的调度和同步都是由用户空间的线程库完成的。由于用户级线程不需要进入内核空间，因此它们的切换比内核级线程快，但是它们无法利用多处理器。</li>
<li>内核级线程（Kernel-Level Thread，KLT）：这种线程由内核创建和管理，它们的调度和同步都是由内核完成的。内核级线程可以利用多处理器，但是它们的切换比用户级线程慢。Linux 中的内核级线程是使用轻量级进程实现的，每个进程都可以拥有多个轻量级进程，也就是说，一个进程可以拥有多个内核级线程。</li>
</ol>
<h2 id="2-pthread库的使用"><a href="#2-pthread库的使用" class="headerlink" title="2. pthread库的使用"></a>2. pthread库的使用</h2><p>pthread是官方提供的用户级的线程库，我们口中所指的线程大多就是指phread库为我们提供的用户级线程。</p>
<h4 id="2-1-头文件"><a href="#2-1-头文件" class="headerlink" title="2.1 头文件"></a>2.1 头文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> <span class="comment">// 头文件 Linux系统默认带pthread库</span></span></span><br></pre></td></tr></table></figure>

<p>pthread不属于标准库，编译时需要带上 -lpthread</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g++ test.cc -o test -lpthread</span><br></pre></td></tr></table></figure>

<h4 id="2-2-pthread-create"><a href="#2-2-pthread-create" class="headerlink" title="2.2 pthread_create"></a>2.2 pthread_create</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION</p>
<p>​	   The  pthread_create()  function  starts  a new thread in the calling process</p>
</blockquote>
<p>这个接口会在当前进程中创建出一个用户级线程</p>
<ul>
<li>第一个参数是线程的id</li>
<li>第二个参数是线程的属性，一般设置为nullptr</li>
<li>第三个参数是函数指针，这个函数的返回值是void*  ，参数为void* ，创建出来的线程会去执行这个函数</li>
<li>第四个参数是start_routine函数传给线程的参数</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>       On success, pthread_create() returns 0; on error, it returns an error number, and the contents of *thread are undefined.</p>
</blockquote>
<p>创建成功时，返回值为0，创建失败返回错误码。</p>
<h4 id="2-3-pthread-join"><a href="#2-3-pthread-join" class="headerlink" title="2.3 pthread_join"></a>2.3 pthread_join</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       The  pthread_join() function waits for the thread specified by thread to terminate.  If that thread has already terminated, then pthread_join() returns immediately.  </p>
<p>​	   The thread specified by thread must be joinable.</p>
</blockquote>
<p>这个接口会一直阻塞等待目标线程执行完毕后回收资源，如果线程已经被回收，会直接返回。</p>
<p>The thread specified by thread must be joinable. 意思是这个线程必须是joinable属性（创建线程时不指定属性的话默认是joinable）或者没有被显式的剥离（调用pthread_detach)。</p>
<p>由于线程占用的资源不会在线程执行完时自己释放，所以需要其他线程执行pthread_join（或者同时调用pthread_detach和pthread_exit)来释放资源，否则就会导致资源的泄露。</p>
<ul>
<li>第一个参数是等待的线程id</li>
<li>第二个参数可以接收等待的线程执行完毕后的返回值</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>       On success, pthread_join() returns 0; on error, it returns an error number.</p>
</blockquote>
<p>等待成功返回0，否则返回错误码</p>
<p>以下是一个简单的线程创建和等待回收的示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;run&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;t,nullptr,run,nullptr) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;pthread_create error\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞等待线程回收</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_join(t,nullptr) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;pthread_join success\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[wyj@VM-20-8-centos ]$ g++ test.cc -o test -lpthread -std=c++11</span><br><span class="line">[wyj@VM-20-8-centos ]$ ./test</span><br><span class="line">run</span><br><span class="line">pthread_join success</span><br></pre></td></tr></table></figure>

<h4 id="2-3-pthread-exit"><a href="#2-3-pthread-exit" class="headerlink" title="2.3 pthread_exit"></a>2.3 pthread_exit</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       The  pthread_exit()  function  terminates  the calling thread and returns a value via retval that (if the thread is joinable) is<br>       available to another thread in the same process that calls pthread_join</p>
</blockquote>
<p>这个接口可以终止运行的线程，进程中其他没有被剥离（调用pthread_detach)的线程可以通过pthread_join接收这个被终止线程的返回值</p>
<ul>
<li>参数retval的值可以被其他线程通过pthread_join获取</li>
</ul>
<p>Linux下线程结束执行有以下几种情况:</p>
<ul>
<li>线程将指定函数体中的代码执行完后自行结束；</li>
<li>线程执行过程中，被同一进程中的其它线程（包括主线程）强制终止；</li>
<li>线程执行过程中，遇到 pthread_exit() 函数结束执行。</li>
</ul>
<p>下面给出几个简单的使用示例：</p>
<p><strong>通过pthread_exit退出线程</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_exit(<span class="string">&quot;pthread_exit&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line">    <span class="comment">// 阻塞等待线程回收</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(t, &amp;ret) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;pthread_join success\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="type">char</span>*)ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ ./test</span><br><span class="line">pthread_join success</span><br><span class="line">pthread_exit</span><br></pre></td></tr></table></figure>

<p>由结果可知，线程调用pthread_exit后提前退出，没有执行后面的printf(“run\n”)，主线程通过pthread_join获得退出值</p>
<p><strong>强制退出线程</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[wyj@VM-20-8-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM-20-8-centos]$ ./test</span><br><span class="line">main thread exit</span><br></pre></td></tr></table></figure>

<p>由执行结果可知，创建出来的线程并没有执行run函数，这是因为本次运行，cpu的调度使得主线程先执行，而且主线程并没有调用pthread_join去阻塞等待子线程，当主线程执行return 0的时候会调用系统接口exit(), exit()会终止进程内的所有线程，所以子线程没有执行run函数就被强制退出了。</p>
<p>如果我们用pthread_exit提前退出主线程，不执行return 0：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;run\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;t, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ gcc test.c -o test -lpthread</span><br><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos]$ ./test</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>由结果可知，主线程提前退出，没有执行return 0，子线程执行了run函数。pthread_exit退出当前线程，不会影响其他线程。</p>
<p><strong>此外，pthread_exit() 可以自动调用线程清理程序（本质是一个由 pthread_cleanup_push() 指定的自定义函数），return 则不具备这个能力。总之在实际场景中，如果想终止某个子线程执行，强烈建议大家使用 pthread_exit() 函数。</strong></p>
<h4 id="2-4-pthread-detach"><a href="#2-4-pthread-detach" class="headerlink" title="2.4 pthread_detach"></a>2.4 pthread_detach</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       The  pthread_detach()  function  marks  the  thread  identified  by  thread as detached.  When a detached thread terminates, its<br>       resources are automatically released back to the system without the need for another thread to join with the terminated thread.</p>
</blockquote>
<p>这个接口会将线程的状态设置为detached，当这个线程执行结束时，资源会被操作系统自动回收，不需要使用者手动调用pthread_join来回收。</p>
<ul>
<li>参数为线程的id</li>
</ul>
<p>我们知道，如果一个线程执行结束但还没有被join时，他的状态类似与进程中的僵尸进程（Zombie Process），需要创建线程的人手动调用pthread_join阻塞回收资源。</p>
<p>但有时我们并不想阻塞等待，导致效率降低，同时为了避免资源泄露，就可以使用pthread_detach，让操作系统替我们管理线程。</p>
<p>通常，在剥离子线程时，我们会让主线程保持在后台运行（常驻内存的程序），从而避免主线程退出，操作系统就自动回收被剥离的子线程，从而避免子线程还未执行完就退出的问题。</p>
<h4 id="2-5-gettid"><a href="#2-5-gettid" class="headerlink" title="2.5 gettid"></a>2.5 gettid</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pid_t gettid(void);</span><br></pre></td></tr></table></figure>

<p>头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       gettid()  returns the caller’s thread ID (TID).  In a single-threaded process, the thread ID is equal to the process ID (PID, as<br>       returned by getpid().  In a multithreaded process, all threads have the same PID, but each one has a unique TID.</p>
</blockquote>
<p>gettid可以获取当前线程的线程tid，当进程内只有一个线程的时候，线程的tid等于进程的pid</p>
<p><strong>gettid是系统接口，需要通过syscall来调用</strong></p>
<h4 id="2-6-syscall"><a href="#2-6-syscall" class="headerlink" title="2.6 syscall"></a>2.6 syscall</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall</span><span class="params">(<span class="type">int</span> number, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span>   <span class="comment">/* For SYS_xxx definitions */</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>syscall()  is  a  small library function that invokes the system call whose assembly language interface has the specified number with the specified arguments.  Employing syscall() is useful, for example, when invoking a system call that has no wrapper function in the C library.</p>
<p>syscall() saves CPU registers before making the system call, restores the registers upon return from the system call, and stores any error code returned by the system call in errno if an error occurs.</p>
</blockquote>
<p>sycall()是一个小型库函数，它调用系统调用，其汇编语言接口具有指定编号和指定参数。例如，当调用C库中没有包装器函数的系统调用时，使用sycall()是有用的。</p>
<p>syscall()在进行系统调用之前保存CPU寄存器，在系统调用返回时恢复寄存器，并存储error中的错误码</p>
<p>以下是一个简单示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> tid;</span><br><span class="line"></span><br><span class="line">    tid = syscall(SYS_gettid);</span><br><span class="line">    tid = syscall(SYS_tgkill, getpid(), tid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-线程互斥"><a href="#3-线程互斥" class="headerlink" title="3.线程互斥"></a>3.线程互斥</h2><h4 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h4><p>线程互斥是指在多个线程中，对同一临界资源的访问进行限制，保证同一时间只有一个线程能够访问该资源，以避免多个线程同时修改同一个资源而导致的数据不一致问题。</p>
<h4 id="3-2-临界资源"><a href="#3-2-临界资源" class="headerlink" title="3.2 临界资源"></a>3.2 临界资源</h4><p>临界资源是指共享的一段代码、一组数据或一块内存区域等，他们能被多个线程访问、修改，所以需要通过互斥访问来保证数据一致性的资源。比如，在一个多线程程序中，多个线程可能同时访问同一份数据结构，这时就需要使用临界资源的互斥访问来保证数据的正确性。</p>
<h4 id="3-3-锁"><a href="#3-3-锁" class="headerlink" title="3.3 锁"></a>3.3 锁</h4><p><strong>锁是一种解决多线程访问临界资源的冲突一种技术。</strong>锁的实现依赖于操作系统的调度和底层硬件的原子性操作。</p>
<h4 id="3-4-pthread-mutex"><a href="#3-4-pthread-mutex" class="headerlink" title="3.4 pthread_mutex"></a>3.4 pthread_mutex</h4><p>pthread_mutex是pthread库中实现的互斥锁，他的实现依赖于futex（fast userspace mutex）系统调用，它是一个基于用户空间和内核空间的协同机制，主要作用是将用户空间的线程挂起等待某个事件发生，并在事件发生时唤醒他们。futex底层实现中涉及到CPU提供的原子操作.</p>
<p>当一个线程想要加锁时，它会首先尝试在用户空间中使用原子操作（如CAS）来获取锁，如果获取成功，则直接返回；否则，线程会调用futex_wait函数挂起自己，并在内核中等待锁的释放。当锁被持有线程释放时，它会调用futex_wake函数唤醒等待的线程，使它们重新竞争锁。在这个过程中，操作系统内核会对锁进行一些状态的维护，例如是否有线程正在等待锁、锁的拥有者等等。</p>
<p>以下是X86架构CPU加锁过程汇编指令的简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock:</span><br><span class="line">    mov eax, 1   ; 将eax寄存器设置为1</span><br><span class="line">    xchg eax, [lock] ; 将eax寄存器中的值与lock变量中的值进行交换，lock变量中的值变为1</span><br><span class="line">    test eax, eax   ; 测试eax寄存器的值是否为0，为0则代表有锁资源</span><br><span class="line">    jnz lock    ; 如果eax寄存器的值不为0，跳转到lock标签处，继续尝试获取锁</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>lock初始化值为0,0代表有锁资源，1代表无锁资源</li>
<li>在单处理机中，一次只有一个线程能上处理机执行xchg指令，是原子性操作</li>
<li>实际的锁实现会更加复杂，涉及到缓存一致性、总线锁定等底层细节。</li>
</ul>
<p>以下是pthread库提供的关于锁操作的接口：</p>
<p><strong>锁变量：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> </span><br></pre></td></tr></table></figure>

<p><strong>初始化锁：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span><br><span class="line">       				   const pthread_mutexattr_t *restrict attr)</span><br><span class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>pthread库提供了两种初始化锁的方式：</p>
<ul>
<li>通过init接口，第二个参数可以设置锁的属性</li>
<li>通过宏 PTHREAD_MUTEX_INITIALIZER只能创建用于静态内存的锁，即在定义时直接声明的变量</li>
</ul>
<p><strong>加锁：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>pthread库提供了两种加锁方式：</p>
<ul>
<li>lock是阻塞式加锁</li>
<li>unlock是非阻塞式加锁</li>
</ul>
<p><strong>解锁：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure>

<p><strong>释放锁：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>以下是不加锁情况下多线程访问临界资源的简单实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">10000</span>; <span class="comment">// 临界区资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">run</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt;<span class="string">&quot;tid：&quot;</span>&lt;&lt;<span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; --count &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, run, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，创建了3个线程去并发执行run函数，count是临界区资源，三个线程都可以访问修改count。</p>
<p>执行结果：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/1.png"></p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/1.1.png"></p>
<p>出现了各种输出错误和数据不一致，这是多线程访问临界资源导致的冲突情况。</p>
<p>以下是加锁以后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1000</span>; <span class="comment">// 临界区资源</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">run</span><span class="params">(<span class="type">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">200</span>);</span><br><span class="line">            std::cout &lt;&lt;<span class="string">&quot;tid：&quot;</span>&lt;&lt;<span class="built_in">syscall</span>(SYS_gettid) &lt;&lt; <span class="string">&quot; count: &quot;</span> &lt;&lt; --count &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pthread_mutex_init(&amp;mutex,nullptr);</span></span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, run, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(threads[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/2.png"></p>
<p>通过加锁解决了多线程访问临界资源冲突的问题。但是通过tid可以看出，整个进程生命周期里，<strong>几乎只有单个线程在执行任务</strong>，并不是我们预期设想的多个线程并发执行任务。</p>
<p>产生这种现象的原因：该线程执行任务的消耗小于CPU切换到其他线程的消耗，所以CPU调度机制会保持该线程运行下去，不会切换线程。这样就会导致其他线程创建出来却没有执行任务，反而浪费了系统的资源，为了解决这个问题，我们引入了<strong>线程同步</strong>。</p>
<h2 id="4-线程同步"><a href="#4-线程同步" class="headerlink" title="4. 线程同步"></a>4. 线程同步</h2><p>当我们对多线程互斥访问同一份资源不作限制时，完全由CPU去进行调度，就有可能会出现上面的线程饥饿现象，导致资源的浪费，因此我们引入了线程同步的概念，在保证线程访问安全的前提下，通过条件变量等机制去控制线程，使得多个线程能够按照一定的顺序、时间和方式执行。</p>
<h4 id="4-1-条件变量"><a href="#4-1-条件变量" class="headerlink" title="4.1 条件变量"></a>4.1 条件变量</h4><p>以下是pthread库提供的条件变量接口：</p>
<p><strong>条件变量：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化：</strong></p>
<p>类似于锁，pthread库提供了两种初始化条件变量方式：</p>
<ul>
<li>init接口，第二个参数可以设置条件变量属性</li>
<li>通过宏 PTHREAD_COND_INITIALIZER只能创建用于静态内存的锁，即在定义时直接声明的变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;              		  </span><br></pre></td></tr></table></figure>

<p><strong>等待条件变量信号：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int pthread_cond_timedwait(pthread_cond_t *restrict cond,</span><br><span class="line">              pthread_mutex_t *restrict mutex,</span><br><span class="line">              const struct timespec *restrict abstime);</span><br><span class="line">int pthread_cond_wait(pthread_cond_t *restrict cond,</span><br><span class="line">              pthread_mutex_t *restrict mutex);</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数为条件变量，第二个参数为锁，目的是<strong>保证条件变量读写的原子性</strong></li>
<li>timedwait接口的多出的第三个参数可以设置等待的时间</li>
</ul>
<p><strong>!!! 注意，pthread库在wait和timewait内部做了类似下面的特殊处理：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">   pthread_mutex_unlock(mutex);</span><br><span class="line">    <span class="comment">// 阻塞等待条件变量信号</span></span><br><span class="line">   	 ...</span><br><span class="line">    <span class="comment">// 收到条件变量信号，如果有锁资源，加锁，没有锁资源，阻塞等待加锁</span></span><br><span class="line">   pthread_mutex_lock(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行条件变量信号等待时，会先进行解锁，阻塞等待条件变量信号，直到收到信号才会进行加锁。<strong>这样处理的目的是防止线程阻塞时占用锁资源，使得其他线程没法及时获得锁资源。</strong></p>
<p>这种特殊处理会导致使用条件变量时出现下面的情况：</p>
<p>收到条件变量信号的某个线程加锁后开始执行任务，其他线程的状态为阻塞等待条件变量信号或者阻塞等待锁资源，但假如拿到锁的线程退出后没有释放锁，就会导致其他线程一只阻塞等待阻塞等待加锁。</p>
<p><strong>为了避免这种情况的发生，需要程序员在程执行完后手动释放锁资源。</strong></p>
<p><strong>发送条件变量信号：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个接口会向所有阻塞在cond条件变量下的线程发送信号</li>
<li>第二个接口会向至少一个阻塞在cond条件变量下的线程发送信号</li>
</ul>
<h4 id="4-2-生产消费者模型–阻塞队列"><a href="#4-2-生产消费者模型–阻塞队列" class="headerlink" title="4.2 生产消费者模型–阻塞队列"></a>4.2 生产消费者模型–阻塞队列</h4><p>生产消费者是线程同步中常用的一个模型，它不仅能保证各种操作的原子性，还能实现访问控制。</p>
<p>生产消费者模型结构：</p>
<ul>
<li>任务队列：存放待执行任务的队列，</li>
<li>生产者：主线程向任务队列中添加任务并通知子线程</li>
<li>消费者：子线程从任务队列中取出任务并通知主线程</li>
</ul>
<p>通过锁来保证生产者添加任务和消费者取出任务操作的原子性，通过条件变量来控制线程。</p>
<p>下面是生产消费者模型的一个简单示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span>&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Task*&gt; queue_;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> *mutex;</span><br><span class="line">    <span class="type">pthread_cond_t</span> *cond;</span><br><span class="line">    <span class="type">int</span> MaxNum;</span><br><span class="line">public:</span><br><span class="line">    TaskQueue(<span class="type">int</span> n)</span><br><span class="line">    :MaxNum(n)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(mutex,nullptr);</span><br><span class="line">        pthread_cond_init(cond,nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(Task *t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mutex);</span><br><span class="line">        <span class="keyword">if</span>(queue_.size()&gt;= MaxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(cond,mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        queue_.push(t);</span><br><span class="line">        pthread_cond_signal(cond);</span><br><span class="line">        pthread_mutex_unlock(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    Task* <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(mutex);</span><br><span class="line">        <span class="keyword">if</span>(queue_.size()== <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(cond,mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        Task *t = queue_.front();</span><br><span class="line">        queue_.pop();</span><br><span class="line">        pthread_cond_signal(cond);</span><br><span class="line">        pthread_mutex_unlock(mutex);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5.线程池"></a>5.线程池</h2><p>线程池是通过<strong>池化技术</strong>实现的一种管理线程的技术栈，通过线程池技术，我们可以将线程的创建和任务的执行解耦开来，从而实现<strong>降低资源消耗</strong>、<strong>提高响应速度</strong> 、<strong>方便线程管理</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Threadpool</span>&#123;</span></span><br><span class="line">private:</span><br><span class="line">    Threadpool(<span class="type">int</span> threadNum)</span><br><span class="line">    :threadNum_(threadNum)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    Threadpool(<span class="type">const</span> Threadpool &amp;)=delete;</span><br><span class="line">    Threadpool &amp; operator =(<span class="type">const</span> Threadpool &amp;)=delete;</span><br><span class="line">    ~Threadpool();</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 获得线程池单例</span></span><br><span class="line">    <span class="type">static</span> Threadpool* <span class="title function_">GetInstance</span><span class="params">(<span class="type">int</span> threadNum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Double Check Lock</span></span><br><span class="line">        <span class="keyword">if</span>(instance == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;Mutex);</span><br><span class="line">            <span class="keyword">if</span>(instance ==nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = new Threadpool(threadNum);</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;Mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务到任务队列</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">addTask</span><span class="params">(<span class="type">void</span>(*)(<span class="type">void</span>*),<span class="type">void</span> *args)</span>;</span><br><span class="line">    <span class="comment">// 添加空任务到任务队列</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">joinAll</span><span class="params">()</span>;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* <span class="title function_">run</span><span class="params">(<span class="type">void</span> *args)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Task</span>&#123;</span></span><br><span class="line">        Task(<span class="type">void</span> (*func)(<span class="type">void</span>*),<span class="type">void</span> *args)</span><br><span class="line">        :args_(args)</span><br><span class="line">        ,func_(func)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> *args_;<span class="comment">// 参数</span></span><br><span class="line">        <span class="type">void</span> (*func_)(<span class="type">void</span> *); <span class="comment">// 任务函数指针</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> Threadpool * instance;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Task*&gt; Taskqueue;<span class="comment">// 任务队列</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> queueMutex;<span class="comment">// 锁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> Mutex; <span class="comment">// 单例锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> queueCond;<span class="comment">// 条件变量</span></span><br><span class="line">    <span class="type">pthread_t</span> * threads; </span><br><span class="line">    <span class="type">int</span> threadNum_;<span class="comment">// 线程数量</span></span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line">Threadpool * Threadpool::instance =nullptr;</span><br><span class="line"><span class="type">pthread_mutex_t</span> Threadpool::Mutex;</span><br><span class="line"></span><br><span class="line">Threadpool::~Threadpool()</span><br><span class="line">&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    pthread_cond_broadcast(&amp;queueCond);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum_;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(threads[i],nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">    delete [] threads;</span><br><span class="line">    pthread_mutex_destroy(&amp;queueMutex);</span><br><span class="line">    pthread_cond_destroy(&amp;queueCond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">Threadpool::run</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;instance-&gt;queueMutex);</span><br><span class="line">        <span class="keyword">while</span>(instance-&gt;Taskqueue.empty() &amp;&amp; !instance-&gt;stop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待线程被唤醒</span></span><br><span class="line">            pthread_cond_wait(&amp;instance-&gt;queueCond,&amp;instance-&gt;queueMutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(instance-&gt;stop)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;instance-&gt;queueMutex);</span><br><span class="line">            pthread_exit(nullptr);</span><br><span class="line">        &#125;</span><br><span class="line">        Task * task = instance-&gt;Taskqueue.front();</span><br><span class="line">        instance-&gt;Taskqueue.pop();</span><br><span class="line">        pthread_mutex_unlock(&amp;instance-&gt;queueMutex);</span><br><span class="line">        <span class="keyword">if</span>(task)</span><br><span class="line">        &#123;</span><br><span class="line">            task-&gt;func_(task-&gt;args_);</span><br><span class="line">            delete task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Threadpool::addTask</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>*),<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    Task *task= new Task(func,args);</span><br><span class="line">    pthread_mutex_lock(&amp;queueMutex);</span><br><span class="line">    Taskqueue.push(task);</span><br><span class="line">    <span class="comment">// 通知消费者消费</span></span><br><span class="line">    pthread_cond_signal(&amp;queueCond);</span><br><span class="line">    pthread_mutex_unlock(&amp;queueMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队列添加空任务</span></span><br><span class="line"><span class="type">void</span> Threadpool:: joinAll()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum_;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        addTask(nullptr,nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Threadpool::Threadpool(<span class="type">int</span> threadNum)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;threadNum_ = threadNum;</span><br><span class="line">    pthread_mutex_init(&amp;queueMutex,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;queueCond,<span class="literal">NULL</span>);</span><br><span class="line">    threads = new <span class="type">pthread_t</span>[threadNum];</span><br><span class="line">    stop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;threads[i],<span class="literal">NULL</span>,run,this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux进程</title>
    <url>/2023/04/29/%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-进程的概念"><a href="#1-进程的概念" class="headerlink" title="1. 进程的概念"></a>1. 进程的概念</h2><ul>
<li>进程是操作系统对正在运行的程序实例的一种抽象</li>
<li>进程是操作系统分配系统资源的基本单位</li>
<li>每个进程之间是相对独立的</li>
</ul>
<p>计算机上运行着各种各样的程序，操作系统系统为了方便管理这些程序，将它们统一抽象成进程，这样就可以以统一的视角去管理这些程序，从而提高对系统资源的管理能力和利用率。</p>
<p>当我们运行一个可执行程序时，操作系统会创建并初始化<strong>进程控制块 PCB（Process Control Block）</strong>，PCB里面就记录了可执行程序的各种属性：状态、标识符、优先级等等，通过这种方式，操作系统就将对可执行程序的管理转化成了对进程控制块的管理，如果使用各种数据结构将所有进程控制块管理起来，操作系统就完成了对计算机上所有可执行程序的管理。</p>
<p>Linux下的进程控制块就是task_struct结构体，以下是一个简化版的task_struct:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;                  <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">thread_info</span>;</span> <span class="comment">// 线程信息</span></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">stack</span>;  <span class="comment">// 进程内核栈</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> <span class="comment">// 父进程指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>  <span class="comment">// 子进程列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">siblings</span>;</span>  <span class="comment">// 兄弟进程列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>       <span class="comment">// 进程地址空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">cwd</span>;</span>           <span class="comment">// 当前工作目录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span> <span class="comment">// 信号信息</span></span><br><span class="line">    <span class="type">int</span> exit_code;              <span class="comment">// 退出状态码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在创建进程控制块时，操作系统做了以下几个主要工作：</p>
<ol>
<li>初始化进程控制块task_struct：它记录了进程的状态、进程标识符、进程优先级等信息。</li>
<li>分配进程地址空间：每个进程都有自己的虚拟地址空间，用于存放代码、数据和堆栈等信息。在创建进程时，内核会为该进程分配一个独立的虚拟地址空间，并将程序、数据和库文件等载入其中。</li>
<li>复制父进程的内存空间：由于 Linux 使用了写时拷贝（Copy-on-Write，COW）技术，因此在创建进程时，内核会将父进程的内存空间复制一份，但是这些内存页并没有被实际复制，而是被标记为只读，当子进程需要修改其中的某个内存页时，内核会为其分配一个新的内存页，并将修改后的数据写入其中。</li>
<li>复制父进程的文件描述符表：文件描述符表是进程用于管理文件和网络连接等资源的数据结构，在创建进程时，内核会将父进程的文件描述符表复制一份，并将其与子进程关联起来。</li>
<li>设置进程的环境变量和命令行参数：每个进程都有自己的环境变量和命令行参数，这些信息用于指定进程的运行环境和参数。在创建进程时，内核会将父进程的环境变量和命令行参数复制一份，并将其与子进程关联起来。</li>
<li>设置进程的信号处理器：信号是进程间通信的一种方式，在 Linux 中，每个进程都可以设置自己的信号处理器。在创建进程时，内核会将父进程的信号处理器复制一份，并将其与子进程关联起来。</li>
</ol>
<h2 id="2-进程控制"><a href="#2-进程控制" class="headerlink" title="2. 进程控制"></a>2. 进程控制</h2><p>在shell命令行中使用ps命令查看系统当前运行的进程：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/2.1.png"></p>
<ul>
<li>PPID是父进程的进程ID</li>
<li>PID是该进程的进程ID</li>
<li>PGID是进程组的ID</li>
<li>SID是当前会话的ID</li>
<li>STAT是当前进程的状态</li>
</ul>
<p>其中，Linux下进程状态有以下几种：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/2.2.png"></p>
<p>其他状态字符：</p>
<ul>
<li>+   &#x2F;&#x2F;位于后台的进程组；</li>
<li>s   &#x2F;&#x2F;进程组组长</li>
<li>&lt;   &#x2F;&#x2F;优先级高的进程 </li>
<li>N   &#x2F;&#x2F;优先级较低的进程 </li>
<li>L   &#x2F;&#x2F;有些页被锁进内存； </li>
<li>l   &#x2F;&#x2F;多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）</li>
</ul>
<h4 id="2-1-fork"><a href="#2-1-fork" class="headerlink" title="2.1 fork"></a>2.1 fork</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       fork()  creates a new process by duplicating the calling process. The new process, referred to as the child, is an exact duplicate of the calling process, referred to as the parent, except for the following points:</p>
</blockquote>
<p>调用fork会在当前进程中创建出新进程（称为子进程），继承父进程下列资源：</p>
<ul>
<li>父进程的代码段、数据段、堆栈段等代码和状态信息</li>
<li>父进程打开的文件描述符</li>
<li>父进程的环境变量、工作目录、umask</li>
<li>父进程的信号处理方式</li>
<li>将父进程的pid设为自己的ppid</li>
</ul>
<p>有以下区别：</p>
<ul>
<li>子进程拥有自己的进程pid、地址空间</li>
<li>子进程的信号量、内存锁、资源利用率、CPU时间计数器全部重置</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>       On  success,  the  PID  of the child process is returned in the parent, and 0 is returned in the<br>       child.  On failure, -1 is returned in the parent, no child process is created, and errno is  set<br>       appropriately.</p>
</blockquote>
<p>如果fork创建成功，fork会在父进程中返回子进程的pid，在子进程中返回0，否则在父进程中返回-1。</p>
<p>以下是一个简单的fork示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;executed\n&quot;</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;fork err\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;pid: &quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot; parent\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ppid: &quot;</span>&lt;&lt;getppid()&lt;&lt;<span class="string">&quot; pid: &quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot; child\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Not executed\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos test]$ ./test</span><br><span class="line">executed</span><br><span class="line">pid: <span class="number">8051</span> parent</span><br><span class="line">Not executed</span><br><span class="line">ppid: <span class="number">8051</span> pid: <span class="number">8052</span> child</span><br><span class="line">Not executed</span><br></pre></td></tr></table></figure>

<p>上述代码中，getpid()可以获取进程pid，getppid（）可以获取父进程pid.</p>
<p>由结果可知，子进程继承了父进程代码段，子进程执行和父进程相同的代码段。</p>
<p><strong>Question:子进程执行和父进程相同的代码段，为什么没有执行std::cout&lt;&lt;”executed\n” ?</strong></p>
<p>原因：子进程继承了父进程的状态信息，其中就包括父进程PC指针寄存器的值，父进程fork时，PC指针指向pid_t pid &#x3D; fork()。因此子进程开始执行代码时，PC指针已经指向了pid_t pid &#x3D; fork() ，并从下一行代码开始执行，所以不会执行std::cout&lt;&lt;”executed\n”。</p>
<h4 id="2-2-写时拷贝（Copy-on-Write，COW）"><a href="#2-2-写时拷贝（Copy-on-Write，COW）" class="headerlink" title="2.2  写时拷贝（Copy-on-Write，COW）"></a>2.2  写时拷贝（Copy-on-Write，COW）</h4><blockquote>
<p>In Linux, when a process creates a new process (child process) through the fork() system call, the new process initially shares the same memory as the parent process. With COW, the operating system only creates a copy of the parent process’s memory pages when the child process modifies them.</p>
</blockquote>
<p>COW技术指fork子进程时，Linux系统内核会为子进程创建独立的地址空间，子进程的页表是父进程页表的一份拷贝，同时设置子进程页表中的写保护标志，此时子进程和父进程共享相同的物理内存。只有当子进程或者父进程需要修改这块共享物理内存上的值时，操作系统会捕获到写保护异常，此时才会开辟新的物理内存空间，填入修改后的值，并将子进程页表中对应的虚拟地址映射到新的物理内存空间上。</p>
<p>这种设计可以避免不必要的物理内存空间拷贝，只有在实际需要修改物理内存时，才会发生数据的复制，从而节省了内存和时间。</p>
<p>以下是一段父进程修改共享物理内存值时，发生写时拷贝的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x =<span class="number">0</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;x&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos test]$ g++ test.cc -o test -<span class="built_in">std</span>=c++<span class="number">11</span></span><br><span class="line">[wyj@VM<span class="number">-20</span><span class="number">-8</span>-centos test]$ ./test</span><br><span class="line"><span class="number">0x7ffdbb1f8618</span>:<span class="number">10</span></span><br><span class="line"><span class="number">0x7ffdbb1f8618</span>:<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>由于子进程拷贝父进程的代码段、数据段、堆栈空间，所以X的虚拟地址相同，当父进程修改x变量的值时，发生了写时拷贝，在物理内存上开辟了新的空间存放子进程x变量的值，并将子进程页表中X的虚拟地址映射到新的物理内存中。而用户只能看到进程空间中的虚拟地址，看不到实际的物理内存地址，这也导致了我们看到了“相同的地址”，存放的值却不同的现象。</p>
<p>刚创建子进程时，父子进程共享同一块物理内存：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.1.png"></p>
<p>父进程修改共享物理内存时：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.2.png"></p>
<h4 id="2-3-exit-x2F-exit"><a href="#2-3-exit-x2F-exit" class="headerlink" title="2.3 exit&#x2F;_exit"></a>2.3 exit&#x2F;_exit</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       The  function  _exit()  terminates  the  calling  process “immediately”.  Any open file descriptors belonging to the process are closed; any children of the process are inherited by process 1, init, and the process’s parent is sent a SIGCHLD signal.</p>
<p>​	  The value status is returned to the parent process as the process’s exit status, and can be collected using one of  the  wait<br>family of calls.</p>
</blockquote>
<p>调用_exit会终止当前进程，关闭当前进程打开的所有文件描述符，<strong>该进程的所有的子进程都会被进程标识符为1的进程继承（就是操作系统）</strong>，同时向该进程的父进程发送SIGCHLD信号，父进程可以通过wait接口获得子进程状态码status。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>

<p>exit与_exit都可以用来终止进程，但有以下区别：</p>
<ul>
<li>_exit立刻终止进程，exit还会执行清理函数</li>
<li>_exit不会刷新缓冲区，exit会刷新缓冲区</li>
</ul>
<p><strong>为了提高系统资源的利用效率，进程终止时，操作系统不会立即释放task_struct，会将它放入到数据结构缓冲池（slab分发器）中，留给下一个进程使用，从而避免频繁的创建task_strcut,增加系统的开销。</strong></p>
<h4 id="2-4-wait"><a href="#2-4-wait" class="headerlink" title="2.4 wait"></a>2.4 wait</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       All of these system calls are used to wait for state changes in a child of the calling process, and obtain information about the<br>       child whose state has changed.  A state change is considered to be: the child terminated; the child was stopped by a signal;  or<br>       the  child  was  resumed  by  a  signal.   In the case of a terminated child, performing a wait allows the system to release the<br>       resources associated with the child; if a wait is not performed, then the terminated child remains  in  a  “zombie”  state  </p>
</blockquote>
<p>wiat接口会阻塞等待某个子进程的状态改变。当子进程状态改变时，wait会获得子进程的状态，释放子进程的资源。如果没有调用wait，子进程将会保持“zombie”状态，成为僵尸进程。</p>
<p>子进程状态改变意味着发生以下情况：</p>
<ul>
<li>子进程被终止</li>
<li>子进程被信号暂停或重启</li>
</ul>
<p>参数的设置：</p>
<ul>
<li>status是输出型参数，有效位为16位，高8位是status，低8位分别是1位core dump标志和7位终止信号</li>
</ul>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.3.png"></p>
<p>我们可以右移8位获得status，按位与获得终止信号，也可以使用内核提供的宏来获得值</p>
<ul>
<li>WEXITSTATUS(status) 提取子进程退出码</li>
<li>WTERMSIG(status) 提取子进程退出信号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">	wait(): on success, returns the process ID of the terminated child; on error, -1 is returned.</span><br></pre></td></tr></table></figure>

<p>成功返回子进程pid，否则返回-1</p>
<h4 id="2-5-waitpid"><a href="#2-5-waitpid" class="headerlink" title="2.5  waitpid"></a>2.5  waitpid</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>在wait基础上，waitpid设置了额外两个参数：</p>
<p>pid：</p>
<ul>
<li>-1 等待任意子进程</li>
<li>0 等待子进程的进程组id等于父进程id</li>
<li>大于0 等待指定pid的子进程</li>
</ul>
<p>option：</p>
<ul>
<li>0 阻塞等待进程状态改变</li>
<li>WNOHANG  非阻塞等待进程状态改变</li>
<li>WCONTINUED 阻塞等待进程收到SIGCONT信号</li>
</ul>
<blockquote>
<p>RETURN VALUE<br>    waitpid(): on success, returns the process ID of the child whose state has changed; if WNOHANG was specified  and  one  or  more<br>       child specified by pid exist, but have not yet changed state, then 0 is returned.  On error, -1 is returned.</p>
</blockquote>
<p>如果有子进程状态改变并等待成功，返回子进程pid。如果option参数设置的WNOHANG，并且存在子进程，但没有子进程状态改变，返回0，否则返回-1.</p>
<p>以下是一个使用waipid的简单示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是子进程 pid:&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status =<span class="number">0</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid ==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我是父进程 pid:&quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep (<span class="number">15</span>);</span><br><span class="line">    waitpid(pid,&amp;status,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;status:&quot;</span>&lt;&lt;WEXITSTATUS(status)&lt;&lt;<span class="string">&quot;signal:&quot;</span>&lt;&lt;WTERMSIG(status)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，在主进程中sleep（15）后再执行waitpid释放资源，子进程退出后没有被回收时，就会处于“zombie”状态。</p>
<p>通过监控脚本来检测进程状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while :;do ps ajx | head -1 &amp;&amp; ps ajx | grep test| grep -v grep;sleep 1; echo &quot;########################&quot;; done</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>如图所示，子进程8682退出后没被操作系统回收前，状态为Z+</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.6.png"></p>
<p>执行完waitpid后，子进程资源被操作系统回收：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.7.png"></p>
<h2 id="3-进程间通信"><a href="#3-进程间通信" class="headerlink" title="3. 进程间通信"></a>3. 进程间通信</h2><h3 id="3-1-管道"><a href="#3-1-管道" class="headerlink" title="3.1 管道"></a>3.1 管道</h3><blockquote>
<p>In Linux, a pipe is a form of interprocess communication that enables data to be transferred between two processes. A pipe is a unidirectional data channel, which means data can flow only in one direction, from the output of one process to the input of another.</p>
</blockquote>
<p>管道是Linux中的一种使用缓冲区的进程间通信的方式。管道是单向数据通道，意味着数据只能在一个方向上传递，从一个进程的输出到一个进程的输入.</p>
<p>我们在shell命令行中常用的 “ |” 就是管道命令。下面的示例中，将ps进程的输出通过管道传输给grep进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps ajx | grep server</span><br></pre></td></tr></table></figure>

<p>Linux中有两种管道创建方式</p>
<ul>
<li>匿名管道</li>
<li>命名管道</li>
</ul>
<h4 id="3-1-1-匿名管道"><a href="#3-1-1-匿名管道" class="headerlink" title="3.1.1 匿名管道"></a>3.1.1 匿名管道</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION</p>
<p>The array pipefd is used to return two file descriptors referring to the ends of the pipe. pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of the pipe. Data written to the write end of the pipe is buffered by the kernel until it is read from the read end of the pipe.</p>
</blockquote>
<ul>
<li>pipefd是输出型参数，调用pipe后，内核分别以读和写的方式打开同一个文件，将两次打开的文件描述符填入到数组中</li>
<li>pipefd[0]是读端文件描述符，pipefd[1]是写端文件描述符</li>
</ul>
<p><strong>通过写端写入的数据会放在Linux内核的缓冲区中，而不是文件里提供的语言级I&#x2F;O 缓冲区</strong>，直到写端读取数据，才会清理缓冲区</p>
<p>下面是Linux内核中匿名管道缓冲区的源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>页面是操作系统管理物理内存的基本单位，它通常是4KB或8KB大小的连续内存块。struct page是用来管理页面的结构体，它存储了页面的状态和属性。每一个struct pipe_buffer对象就对应一个页面。当我们使用管道进行通信的时候，会先将写端进程地址空间里的缓冲区的数据通过page指针访问页面然后拷贝到页面中，offset和len就会记录数据的偏移量和长度，然后读端就可以通过page指针和offset和len去访问页面中的这段数据，拷贝到读端进程空间缓冲区。</p>
<p>因为管道是单向数据通道，我们在使用pipe进行父子进程间通信，需要在父子进程中分别关闭读写的某一端，防止出现读写的错误</p>
<ul>
<li>如果是父进程向子进程发送数据：关闭父进程的读端，关闭子进程的写端</li>
<li>如果是子进程向父进程发送数据：关闭父进程的写端，关闭子进程的读端</li>
</ul>
<p>以下是一个简单示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipefd);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">20</span>]=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        write(pipefd[<span class="number">1</span>],buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;pid: &quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot; write:&quot;</span>&lt;&lt;buffer&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        read(pipefd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;pid: &quot;</span>&lt;&lt;getpid()&lt;&lt;<span class="string">&quot; read:&quot;</span>&lt;&lt;buf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(waitpid(pid,&amp;status,<span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;status: &quot;</span>&lt;&lt;WEXITSTATUS(status)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;wait err\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/3.9.png"></p>
<p>上述示例中，父进程创建匿名管道后fork创建子进程，子进程会复制父进程的进程控制块task_struct中的文件信息file_struct:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span><span class="comment">//文件数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的fd_array就是文件指针数组，里面的指针就指向了进程打开的文件表。所以子进程的文件指针数组指向了父进程打开的文件表，其中就包括管道文件(如果你对以上文件知识有疑惑，请阅读<a href="https://blog.musnow.top/posts/2864480005/">Linux文件系统</a>)，所以父子进程就可以通过同一个管道文件进行通信。当父进程调用write向内核缓冲区写入数据时，内核就会通知子进程区读取数据</p>
<ul>
<li>当内核管道缓冲区为空时，read接口会阻塞等待write接口写入数据</li>
<li>当内核管道缓冲区写满时，wtire接口会阻塞等待read接口读取数据</li>
</ul>
<p>这个同步&#x2F;阻塞机制是Linux管道文件中自带的。内核中是通过等待队列来实现的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nrbufs, curbuf;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> waiting_writers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">bufs</span>[<span class="title">PIPE_BUFFERS</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等待队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span> lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>文件系统提供了用户级的I&#x2F;O 缓冲区，为什么还要专门使用内核级的管道缓冲区呢？</strong></p>
<ul>
<li>隔离性：内核级别的缓冲区保证了管道通信数据不会泄露到其他进程，从而提供了较好的隔离性。这使得数据在进程间传输时具有更高的安全性和可靠性。</li>
<li>同步和阻塞：内核级别的缓冲区允许管道在特定条件下进行同步和阻塞。例如，当管道为空时，读取操作会阻塞；当管道满时，写入操作会阻塞。这种特性有助于在进程间实现简单的同步和协作。</li>
<li>数据持久性：内核级别的缓冲区可以确保在进程终止时数据不会丢失。例如，当一个进程在管道中写入数据后终止，另一个进程仍然可以从管道中读取这些数据。</li>
<li>通用性：由于管道是一种通用的进程间通信机制，因此内核级别的缓冲区可以确保不同进程之间无需考虑底层实现细节就能进行通信。</li>
</ul>
<h4 id="3-1-2-命名管道"><a href="#3-1-2-命名管道" class="headerlink" title="3.1.2 命名管道"></a>3.1.2 命名管道</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DESCRIPTION<br>       mkfifo()  makes a FIFO special file with name pathname.  mode specifies the FIFO’s permissions.  It is modified by the process’s<br>       umask in the usual way: the permissions of the created file are (mode &amp; ~umask).</p>
<p>​	A FIFO special file is similar to a pipe, except that it is created in a different way.  Instead of being an anonymous  communications channel, </p>
<p>​		a FIFO special file is entered into the file system by calling mkfifo().</p>
</blockquote>
<ul>
<li>pathname  以文件系统的方式指定管道文件名</li>
<li>mode 以文件系统的方式指定管道文件权限</li>
</ul>
<p>命名管道和匿名管道有以下区别：</p>
<ul>
<li>命名管道是通过文件系统中的文件名来访问的，而匿名管道不存在对应的文件，只存在于内存中，无法在文件系统中访问。</li>
<li>命名管道可以在进程间传递数据，即使它们没有任何关系，只要它们能够访问同一个文件系统。而匿名管道只有通过 fork() 系统调用创建出来的父子进程之间可以使用匿名管道通信。</li>
<li>命名管道具有持久性，即使所有使用该管道的进程都退出，命名管道仍然存在于文件系统中，直到显式地删除它。而匿名管道是暂时性的，只存在于相关进程运行期间。</li>
</ul>
<p>以下是服务端和多进程客户端使用命名管道文件通信的简单示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server.cc</span><br><span class="line">  <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">  <span class="number">4</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">  <span class="number">5</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">  <span class="number">6</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">  <span class="number">7</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="keyword">define</span> FIFONAME <span class="string">&quot;fifo&quot;</span></span></span><br><span class="line">  <span class="number">9</span> </span><br><span class="line"> <span class="number">10</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> 11 &#123;</span><br><span class="line"> <span class="number">12</span>     mkfifo(FIFONAME,<span class="number">0666</span>);</span><br><span class="line"> <span class="number">13</span>     <span class="type">int</span> fd = open(FIFONAME,O_RDONLY);</span><br><span class="line"> <span class="number">14</span>     <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line"> <span class="number">15</span>     &#123;   </span><br><span class="line"> <span class="number">16</span>         <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"> <span class="number">17</span>         <span class="type">size_t</span> s =read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"> <span class="number">18</span>         <span class="keyword">if</span>(s &gt; <span class="number">0</span>)</span><br><span class="line"> <span class="number">19</span>         &#123;</span><br><span class="line"> <span class="number">20</span>             <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line"> <span class="number">21</span>         &#125;</span><br><span class="line"> <span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="number">0</span>)</span><br><span class="line"> <span class="number">23</span>         &#123;</span><br><span class="line"> <span class="number">24</span>             <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">25</span>         &#125;</span><br><span class="line"> <span class="number">26</span>     &#125;</span><br><span class="line"> <span class="number">27</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">client.cc</span><br><span class="line">  <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">  <span class="number">4</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">  <span class="number">5</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">  <span class="number">6</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">  <span class="number">7</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="keyword">define</span> FIFONAME <span class="string">&quot;fifo&quot;</span></span></span><br><span class="line">  <span class="number">9</span> </span><br><span class="line"> <span class="number">10</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> 11 &#123;</span><br><span class="line"> <span class="number">12</span>     fork();</span><br><span class="line"> <span class="number">13</span>     <span class="type">char</span> info[<span class="number">20</span>]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"> <span class="number">14</span>     <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"> <span class="number">15</span>     <span class="type">int</span> fd = open(FIFONAME,O_WRONLY);</span><br><span class="line"> <span class="number">16</span>     <span class="built_in">sprintf</span>(buf,<span class="string">&quot;ppid:%d pid:%d write:%s \n&quot;</span>,getppid(),getpid(),info);                                    <span class="number">17</span>     write(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"> <span class="number">18</span>     wait(nullptr);</span><br><span class="line"> <span class="number">19</span> &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.0.png"></p>
<h3 id="3-2-共享内存"><a href="#3-2-共享内存" class="headerlink" title="3.2 共享内存"></a>3.2 共享内存</h3><p>共享内存是一种进程间通信的机制，它允许不同进程之间共享同一段物理内存区域，以达到高效传递大量数据的目的。在 Linux 系统中，共享内存由系统内核维护，使用时需要调用相应的系统调用，包括 <code>shmget()</code>、<code>shmat()</code>、<code>shmdt()</code>、<code>shmctl()</code>、<code>ftok()</code> 等.</p>
<p><strong>共享内存和管道的区别：</strong></p>
<ul>
<li>共享内存直接访问内存，而管道需要通过内核缓冲区进行数据的拷贝，因此共享内存具有传输速度快、效率高的优点.</li>
<li>共享内存是直接访问内存，因此不适合用于传输敏感数据，需要应用层自行实现锁机制等保护机制以确保数据的安全性.</li>
<li>共享内存没有访问控制，需要用户设置访问控制，例如信号量.</li>
</ul>
<p>为了实现进程间通信，让不同进程间能访问到同一块内存，共享内存的实现机制类似于命名管道让用户自己指定管道文件路径，提供了<code>ftok()</code>接口让用户自己生成共享内存的编号.</p>
<h4 id="3-2-1-ftok"><a href="#3-2-1-ftok" class="headerlink" title="3.2.1 ftok"></a>3.2.1 ftok</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>pathname是工作文件路径</li>
<li>proj_id是你的当前工程的编号（非0，至少8位）</li>
</ul>
<blockquote>
<p>DESCRIPTION<br>       The  ftok() function uses the identity of the file named by the given pathname (which must refer to an existing, accessible file) and the least significant 8 bits of proj_id (which must be nonzero) to generate a key_t type System V IPC key</p>
</blockquote>
<p>ftok会根据你提供的两个参数生成一个内存空间的key，用户就可以通过这个key去申请内存空间.</p>
<h4 id="3-2-2-shmget"><a href="#3-2-2-shmget" class="headerlink" title="3.2.2 shmget"></a>3.2.2 shmget</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>key 就是ftok生成的内存空间key</li>
<li>size是内存空间大小，应为4Kb的整数倍，因为系统I&#x2F;O的基本单位是4Kb，否则会出现内存空间浪费的情况</li>
<li>shmflg是创建共享内存的方式</li>
</ul>
<p><code>IPC_CREAT:</code>创建共享内存。如果存在则获取，如果不存在则创建后获取</p>
<p><code>IPC_EXCL: </code>必须配合IPC_CREAT使用，如果不存在指定的共享内存，就进行创建；如果该共享内存存在，则出错返回（即保证获取到的共享内存一定是当前进程创建的，是一个新的共享内存）</p>
<p>返回值：</p>
<blockquote>
<p>RETURN VALUE<br>       On success, a valid shared memory identifier is returned.  On errir, -1 is returned, and  errno  is  set  to  indicate  the</p>
<p>error.</p>
</blockquote>
<p><code>shmget</code>会帮我们在内存上开辟出一段空间，如果成功返回这块内存空间的唯一标识符，否则返回-1.</p>
<h4 id="3-2-3-shmat-x2F-shmdt"><a href="#3-2-3-shmat-x2F-shmdt" class="headerlink" title="3.2.3 shmat&#x2F;shmdt"></a>3.2.3 shmat&#x2F;shmdt</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>shmid  shmget返回的内存空间标识符</li>
<li>shmaddr 指定共享内存连接到当前进程中的地址位置。通常为空，表示让系统来选择共享内存的地址</li>
<li>shmflg 使用共享内存的方式，一般设置为0,默认以读写打开</li>
</ul>
<p>返回值：</p>
<blockquote>
<p>RETURN VALUE<br>       On  success shmat() returns the address of the attached shared memory segment; on<br>       error (void *) -1 is returned, and errno is set to  indicate  the  cause  of  the<br>       error.</p>
</blockquote>
<p><code>shmat</code>会将共享内存空间和我们的进程关联起来，将这段共享内存通过页表映射到我们的进程地址空间上，我们将需要通信的进程分别和这块共享内存进行关联，就可以在各自的进程中使用同一块内存空间进行通信.如果创建成功就返回这块内存的起始地址.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>shmaddr就是shmat的返回值</li>
</ul>
<blockquote>
<p>RETURN VALUE</p>
<p>​		On success shmdt() returns 0; on error -1 is returned, and errno is set to indicate the cause of the error.</p>
</blockquote>
<p>shmdt就是解除进程和共享内存的关联</p>
<h4 id="3-2-4-shmctl"><a href="#3-2-4-shmctl" class="headerlink" title="3.2.4 shmctl"></a>3.2.4 shmctl</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>shmid 内存空间的唯一标识符</li>
<li>buf 一般设置为NULL</li>
<li>cmd是操作类型</li>
</ul>
<p><code>IPC_RMID：</code>删除共享内存</p>
<p><code>IPC_STAT：</code>把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值</p>
<p><code>IPC_SET：</code>如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值、</p>
<p>shmid_ds结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uid_t</span> shm_perm.uid;</span><br><span class="line">    <span class="type">uid_t</span> shm_perm.gid;</span><br><span class="line">    <span class="type">mode_t</span> shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是一个创建共享内存的简单示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PATHNAME <span class="string">&quot;/home/wyj/test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key =ftok(PATHNAME,<span class="number">2107120119</span>);</span><br><span class="line">    <span class="type">int</span> id =shmget(key,<span class="number">4096</span>,IPC_CREAT | IPC_EXCL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过ipc命令查看开辟的共享内存空间:</p>
<blockquote>
<p>ipcs -c #查看消息队列&#x2F;共享内存&#x2F;信号量<br>ipcs -s #单独查看信号量<br>ipcs -q #单独查看消息队列<br>ipcs -m #单独查看共享内存</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipcs -m </span><br></pre></td></tr></table></figure>

<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.1.png"></p>
<p>进程关联共享内存后，进行通信：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server.cc</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHNAME <span class="string">&quot;/home/wyj/test&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PATHNAME, <span class="number">2107120119</span>);</span><br><span class="line">    <span class="type">int</span> id = shmget(key, <span class="number">4096</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> *addr = (<span class="type">int</span> *)shmat(id, nullptr, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; addr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    shmdt(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">client.cc</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHNAME <span class="string">&quot;/home/wyj/test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PATHNAME, <span class="number">2107120119</span>);</span><br><span class="line">    <span class="type">int</span> id = shmget(key, <span class="number">4096</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="type">int</span> *addr = (<span class="type">int</span> *)shmat(id, nullptr, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        addr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://lemon-pi.oss-cn-beijing.aliyuncs.com/img/4.2.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
